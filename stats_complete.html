<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sensor and Lock Mechanics Sandbox v4.3</title>
<style>
:root {
--bg-color: #000000;
--panel-bg: #161b22;
--text-main: #c9d1d9;
--text-dim: #8b949e;
--accent: #58a6ff;
--danger: #f85149;
--warning: #d29922;
--success: #3fb950;
--border: #30363d;
--font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        --tag-sys: #a371f7;
        --tag-tgt: #d29922;
        --tag-dmy: #3fb950;
        --tag-allie: #00d9ff;
        --tag-enemy: #ff4500;
        --tag-plr: #3fb950;
    }
    * { box-sizing: border-box; }
    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-main);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    /* Layout */
    header {
        height: 40px;
        background: var(--panel-bg);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        padding: 0 1rem;
        justify-content: space-between;
    }
    h1 { font-size: 14px; margin: 0; font-weight: 600; color: var(--accent); letter-spacing: 0.5px; }
    #workspace {
        flex: 1;
        display: flex;
        overflow: hidden;
    }
    #viewport {
        flex: 1;
        position: relative;
        background-color: var(--bg-color); 
        cursor: crosshair;
        overflow: hidden;
    }
    canvas { display: block; width: 100%; height: 100%; }
    #overlay-ui {
        position: absolute;
        top: 10px;
        left: 10px;
        pointer-events: none;
        font-family: var(--font-mono);
        font-size: 11px;
        color: var(--success);
        text-shadow: 0 1px 2px black;
    }
    #range-legend {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(22, 27, 34, 0.95);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 8px 12px;
        pointer-events: auto;
        font-family: var(--font-mono);
        font-size: 10px;
        color: var(--text-main);
        display: none;
    }
    #range-legend.visible {
        display: block;
    }
    .legend-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 4px;
        font-size: 11px;
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin: 2px 0;
        gap: 8px;
    }
    .legend-color {
        width: 20px;
        height: 10px;
        border-radius: 2px;
    }
    /* Controls Sidebar */
    #controls {
        width: 460px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        font-size: 12px;
    }
    .panel-section {
        padding: 10px;
        border-bottom: 1px solid var(--border);
    }

    .panel-title {
        font-weight: bold;
        color: var(--text-dim);
        text-transform: uppercase;
        font-size: 10px;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    /* Widgets */
    .control-group {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    label { color: var(--text-main); flex: 1; margin-right: 10px; white-space: nowrap; display: flex; align-items: center;}
    
    input[type="range"] {
        flex: 2;
        height: 4px;
        background: var(--border);
        border-radius: 2px;
        appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 12px;
        height: 12px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
    }

    input[type="number"] {
        width: 70px;
        padding: 4px;
        background: var(--bg-color);
        color: var(--text-main);
        border: 1px solid var(--border);
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono);
    }

    input[type="checkbox"] {
        cursor: pointer;
    }

    input[type="text"] {
        width: 100%;
        padding: 4px;
        background: var(--bg-color);
        color: var(--text-main);
        border: 1px solid var(--border);
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono);
    }

    .val-display { width: 50px; text-align: right; color: var(--accent); font-family: var(--font-mono); font-size: 11px; }

    select {
        background: var(--border);
        color: var(--text-main);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        flex: 1;
    }

    button {
        background: var(--border);
        color: var(--text-main);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.2s;
    }
    button:hover { background: #3c444d; }
    button.primary { background: var(--success); color: white; border: none; }
    button.danger { background: var(--danger); color: white; border: none; }
    
    /* Active Mode Button Style */
    button.mode-active {
        background: var(--accent);
        color: #0d1117;
        border-color: var(--accent);
        font-weight: bold;
    }

    /* Ownership Tags */
    .tag {
        font-size: 9px;
        padding: 1px 3px;
        border-radius: 3px;
        margin-right: 6px;
        font-family: var(--font-mono);
        font-weight: bold;
        color: #0d1117;
    }
    .tag-sys { background-color: var(--tag-sys); }
    .tag-tgt { background-color: var(--tag-tgt); }
    .tag-dmy { background-color: var(--tag-dmy); }
    .tag-allie { background-color: var(--tag-allie); }
    .tag-enemy { background-color: var(--tag-enemy); }
    .tag-plr { background-color: var(--tag-plr); }

    .legend-row {
        display: flex; gap: 10px; font-size: 10px; color: var(--text-dim); margin-top: 5px;
    }

    /* Logs */
    #log-panel {
        flex: 1;
        background: #000;
        font-family: var(--font-mono);
        padding: 5px;
        overflow-y: auto;
        font-size: 10px;
        border-top: 1px solid var(--border);
        max-height: 200px;
        min-height: 100px;
    }
    .log-entry { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 2px; }
    .log-time { color: var(--text-dim); margin-right: 5px; }
    .log-type-INFO { color: var(--accent); }
    .log-type-LOCK { color: var(--warning); }
    .log-type-WARN { color: var(--danger); }
    .log-tag { font-weight: bold; margin-right: 4px; }

    /* Modal/Assumptions */
    .modal {
        display: none;
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 100;
        justify-content: center;
        align-items: center;
    }
    .modal-content {
        background: var(--panel-bg);
        border: 1px solid var(--border);
        width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        padding: 20px;
        border-radius: 6px;
    }
    .modal-header { font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 10px;}
    .assumption-list li { margin-bottom: 5px; color: var(--text-dim); }
    
    /* Utility classes */
    .flex-row { display: flex; gap: 5px; }
    .active-entity { border-left: 3px solid var(--accent); background: rgba(88, 166, 255, 0.1); }
    
    /* Entity List */
    #entity-list { max-height: 150px; overflow-y: auto; }
    .entity-item { 
        padding: 4px; border-bottom: 1px solid var(--border); 
        cursor: pointer; display: flex; justify-content: space-between; align-items: center;
    }
    .entity-item:hover { background: rgba(255,255,255,0.05); }
    .entity-item .delete-btn {
        padding: 2px 6px;
        font-size: 10px;
        margin-left: 5px;
    }

    /* Ship Profile Info */
    .profile-info {
        font-size: 10px;
        color: var(--text-dim);
        margin-top: 3px;
        font-style: italic;
    }

.threat-indicator {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 200;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    border-radius: 8px;
    min-width: 160px;
    max-width: 360px;
    box-sizing: border-box;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(20,16,16,0.70), rgba(20,16,16,0.55));
    border: 1px solid rgba(248,81,73,0.35);
    backdrop-filter: blur(6px) saturate(120%);
    color: var(--danger);
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 700;
    text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    box-shadow: 0 8px 20px rgba(0,0,0,0.6);
}

    .threat-indicator .ti-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(180deg, rgba(248,81,73,1), rgba(255,120,100,1));
        color: #0d1117;
        font-size: 13px;
        flex: 0 0 20px;
        box-shadow: 0 2px 6px rgba(248,81,73,0.25);
    }

    .threat-indicator .ti-text {
        overflow: visible;
        white-space: normal;
        font-weight: 700;
        line-height: 1.1;
    }

    @media (max-width: 760px) {
        .threat-indicator {
            top: 12px;
            bottom: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            max-width: 92%;
            white-space: normal;
            text-overflow: clip;
            padding: 10px 12px;
        }
    }
    .threat-indicator { display: none; }
    .threat-indicator.visible { display: flex !important; }

    #range-legend {
        transition: bottom 0.12s ease;
    }
    #range-legend.shift-up {
        bottom: 70px;
    }

    #range-legend { z-index: 150; }
    .threat-indicator { z-index: 200; }
    
    .dual-input-group {
        display: flex;
        gap: 8px;
        align-items: center;
        flex: 2;
    }

    .dual-input-group input[type="range"] {
        flex: 1;
    }

    .profile-creator {
        background: rgba(88, 166, 255, 0.05);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
    }

    .profile-creator h4 {
        margin: 0 0 8px 0;
        font-size: 11px;
        color: var(--accent);
    }

    .profile-creator .control-group {
        margin-bottom: 6px;
    }

    .profile-creator label {
        font-size: 10px;
    }

    .profile-creator input[type="number"],
    .profile-creator input[type="text"],
    .profile-creator select {
        width: 100%;
    }

    .weapon-info-panel {
        background: rgba(210, 153, 34, 0.05);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
        font-size: 10px;
    }

    .weapon-info-panel h4 {
        margin: 0 0 6px 0;
        font-size: 11px;
        color: var(--warning);
    }

    .weapon-stat {
        display: flex;
        justify-content: space-between;
        margin: 3px 0;
        padding: 2px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .weapon-stat-label {
        color: var(--text-dim);
    }

    .weapon-stat-value {
        color: var(--accent);
        font-family: var(--font-mono);
    }

    .weapons-container {
        background: rgba(210, 153, 34, 0.05);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
    }

    .weapons-container h4 {
        margin: 0 0 8px 0;
        font-size: 11px;
        color: var(--warning);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    #entity-weapons-list {
        max-height: 200px;
        overflow-y: auto;
    }

    .weapon-slot {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--border);
        padding: 6px;
        border-radius: 3px;
        margin-bottom: 6px;
    }

    .weapon-slot-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .weapon-slot-controls {
        display: flex;
        gap: 4px;
        align-items: center;
    }

    .weapon-slot-controls select {
        flex: 1;
        min-width: 120px;
    }

    .weapon-slot-controls input[type=\"number\"] {
        width: 60px;
    }

    .weapon-slot-delete {
        padding: 2px 6px;
        font-size: 10px;
    }

</style>
</head>
<body>

<header>
<div style="display:flex; align-items:center; gap:15px;">
<h1>Sensor and Lock Mechanics Sandbox v4.3</h1>
<div class="flex-row">
<button id="btn-play">Pause</button>
<button id="btn-step">Step</button>
<button id="btn-reset">Reset</button>
</div>
</div>
<div class="flex-row">
<button id="btn-telemetry-toggle" title="Toggle telemetry overlays (synced with Telemetry Mode select)">Telemetry</button>
<button id="btn-test-preset">Import State</button>
<button id="btn-assumptions">System Info</button>
<button id="btn-export">Export State</button>
<button id="btn-run-tests">Run Perf Tests</button>
</div>
</header>

<div id="workspace">
<div id="viewport">
<canvas id="main-canvas"></canvas>
<div id="overlay-ui">
<div>PLAYER POS: <span id="hud-player-pos">0,0</span></div>
<div>PLAYER: <span id="hud-player-state">ACTIVE</span></div>
<div>CONTACTS: <span id="hud-contacts">0</span></div>
<div>LOCK OUT: <span id="hud-lock-outgoing">NONE (0%)</span></div>
<div>LOCK IN: <span id="hud-lock-incoming">NONE</span></div>
<div>WEAPON: <span id="hud-weapon-name">NONE</span></div>
<div>HIT PROB: <span id="hud-hit-prob">0%</span></div>
<div style="margin-top: 5px; color: var(--text-dim);" id="hud-selection"></div>
</div>
<div id="range-legend" class="visible">
    <div class="legend-title">RANGE LEGEND</div>
    <div id="legend-static">
        <div class="legend-item">
            <div class="legend-color"></div>
            <span>Entity Relative</span>
        </div>
        <div class="legend-item">
            <div class="legend-color"></div>
            <span>Player Detection Range</span>
        </div>
        <div class="legend-item">
            <div class="legend-color"></div>
            <span>Weapon Effective Range</span>
        </div>
    </div>
    <div class="legend-title" style="margin-top:6px;">SELECTED / HOVER</div>
    <div id="legend-dynamic"></div>
</div>
<div id="threat-warning" class="threat-indicator" style="display:none;">
⚠ INCOMING LOCK DETECTED
</div>
</div>
<div id="controls">
    <div class="panel-section">
        <div class="panel-title">CONTROL LEGEND</div>
        <div class="legend-row">
            <div><span class="tag tag-sys">SYS</span>System</div>
            <div><span class="tag tag-plr">PLR</span>Player</div>
            <div><span class="tag tag-tgt">TGT</span>Target</div>
            <div><span class="tag tag-allie">ALLIE</span>Allie</div>
            <div><span class="tag tag-enemy">ENEMY</span>Enemy</div>
        </div>
    </div>

    <div class="panel-section" id="entity-control-panel">
        <div class="panel-title">ENTITY CONTROL <span id="entity-control-id">---</span></div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Ship Type</label>
            <select id="entity-ship-type">
            </select>
        </div>
        <div class="profile-info" id="entity-profile-description"></div>
        
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Team</label>
            <select id="entity-team">
                <option value="alpha">Team Alpha</option>
                <option value="beta">Team Beta</option>
            </select>
        </div>
        
        
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Velocity (m/s)</label>
            <div class="dual-input-group">
                <input type="range" id="entity-vel" min="0" max="200" step="1" value="0">
                <input type="number" id="entity-vel-num" min="0" max="200" step="1" value="0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Heading (deg)</label>
            <div class="dual-input-group">
                <input type="range" id="entity-head" min="0" max="360" step="5" value="0">
                <input type="number" id="entity-head-num" min="0" max="360" step="1" value="0">
            </div>
        </div>
        <div class="weapons-container">
            <h4>
                WEAPON LOADOUT
                <button id="btn-add-weapon-slot" class="primary" style="font-size: 10px; padding: 2px 6px;">+ Add Slot</button>
            </h4>
            <div id="entity-weapons-list"></div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Sensor Mode</label>
            <div class="flex-row" id="sensor-mode-group">
                <button id="btn-sensor-active">Active</button>
                <button id="btn-sensor-passive">Passive</button>
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Sensor Power</label>
            <div class="dual-input-group">
                <input type="range" id="entity-sensor-power" min="0.1" max="2.0" step="0.1" value="1.0">
                <input type="number" id="entity-sensor-power-num" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>ECM Level</label>
            <div class="dual-input-group">
                <input type="range" id="entity-ecm" min="0" max="5" step="0.1" value="0">
                <input type="number" id="entity-ecm-num" min="0" max="5" step="0.1" value="0">
            </div>
        </div>
        
        <div style="margin-top:10px; padding-top:10px; border-top:1px solid var(--border); font-size:10px; color:var(--text-dim);">
            <div>Signature: <span id="info-sig" style="color:var(--accent)">0</span></div>
            <div>Activity: <span id="info-activity" style="color:var(--accent)">0%</span></div>
            <div>Weapon Activity: <span id="info-weapon-activity" style="color:var(--accent)">0%</span></div>
            <div>Detection: <span id="info-detection" style="color:var(--accent)">0</span></div>
        </div>

        <div class="weapon-info-panel" id="weapon-info-panel" style="display:none;">
            <h4>ACTIVE WEAPON</h4>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Name:</span>
                <span class="weapon-stat-value" id="weapon-name-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Base Accuracy:</span>
                <span class="weapon-stat-value" id="weapon-accuracy-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Effective Range:</span>
                <span class="weapon-stat-value" id="weapon-range-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Activity Weight:</span>
                <span class="weapon-stat-value" id="weapon-activity-weight-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Tracking Speed:</span>
                <span class="weapon-stat-value" id="weapon-tracking-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Guidance:</span>
                <span class="weapon-stat-value" id="weapon-guidance-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Sensitivity:</span>
                <span class="weapon-stat-value" id="weapon-sensitivity-display">-</span>
            </div>
            <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">
                <div class="weapon-stat">
                    <span class="weapon-stat-label">Distance Factor:</span>
                    <span class="weapon-stat-value" id="weapon-dist-factor">0%</span>
                </div>
                <div class="weapon-stat">
                    <span class="weapon-stat-label">Tracking Factor:</span>
                    <span class="weapon-stat-value" id="weapon-track-factor">0%</span>
                </div>
                <div class="weapon-stat">
                    <span class="weapon-stat-label">Hit Probability:</span>
                    <span class="weapon-stat-value" id="weapon-hit-prob-display">0%</span>
                </div>
            </div>
        </div>

        <div class="profile-creator">
            <h4>CREATE CUSTOM SHIP PROFILE</h4>
            <div class="control-group">
                <label>Profile Name</label>
                <input type="text" id="custom-profile-name" placeholder="e.g., Custom Fighter">
            </div>
            <div class="control-group">
                <label>Base Signature</label>
                <input type="number" id="custom-profile-sig" min="1" max="200" step="1" value="20">
            </div>
            <div class="control-group">
                <label>Activity Gain</label>
                <input type="number" id="custom-profile-gain" min="0.1" max="5.0" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <label>Size Class</label>
                <select id="custom-profile-size">
                    <option value="xs">XS — 200-499 m (Corvette / Small)</option>
                    <option value="s">S  — 500-999 m (Frigate / Light)</option>
                    <option value="m" selected>M  — 1.0-1.999 km (Cruiser / Medium)</option>
                    <option value="l">L  — 2.0-2.999 km (Battlecruiser / Large)</option>
                    <option value="xl">XL — 3.0-4.0 km (Capital)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Description</label>
                <input type="text" id="custom-profile-desc" placeholder="Short description">
            </div>
            <button id="btn-save-profile" class="primary" style="width:100%; margin-top:5px;">Save Profile</button>
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">SPAWN DEFAULTS</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Ship Type</label>
            <select id="default-ship-profile">
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Team</label>
            <select id="default-team">
                <option value="alpha">Team Alpha</option>
                <option value="beta">Team Beta</option>
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Weapon</label>
            <select id="default-weapon">
            </select>
        </div>
        <div class="profile-info" id="profile-description">
            Select a ship profile to see description
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">DETECTION SYSTEM</div>
        <div id="params-detection-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">TRACKING & LOCK</div>
        <div id="params-tracking-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">WEAPON HIT PROBABILITY</div>
        <div id="params-weapon-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">ADVANCED SYSTEM MATH</div>
        <div id="params-math-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">PERFORMANCE & DEBUG</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Telemetry Mode</label>
            <select id="telemetry-mode-select">
                <option value="off">Off</option>
                <option value="perf">Performance (Minimal Info)</option>
                <option value="full">Full Telemetry</option>
                <option value="relative-all">Relative (all entities)</option>
            </select>
        </div>
        <div id="relative-options" style="display:none; margin-bottom:6px;">
            <div class="control-group">
                <label>Relative Pairs</label>
                <select id="relative-mode-select">
                    <option value="controlled">Source → Controlled</option>
                    <option value="all">Source → All Entities</option>
                </select>
            </div>
            <div class="control-group">
                <label>Include Allies</label>
                <input type="checkbox" id="relative-include-allies" checked>
            </div>
            <div class="control-group">
                <label>Include Enemies</label>
                <input type="checkbox" id="relative-include-enemies" checked>
            </div>
            <div class="control-group">
                <label>Nearest Targets (N)</label>
                <input type="number" id="relative-max-targets" min="1" max="50" value="5" style="width:70px;">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Show Range Rings</label>
            <input type="checkbox" id="show-range-rings" checked>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Show Range Legend</label>
            <input type="checkbox" id="show-range-legend" checked>
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">VIEW CONTROLS</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Zoom Level</label>
            <div class="dual-input-group">
                <input type="range" id="zoom-slider" min="0.05" max="5" step="0.05" value="0.15">
                <input type="number" id="zoom-val-num" min="0.05" max="5" step="0.05" value="0.15">
            </div>
        </div>
        <div class="control-group">
            <button id="btn-fit-grid" class="primary" style="width:100%;">Fit Grid</button>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Telemetry Overlays</label>
            <input type="checkbox" id="telemetry-toggle">
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">
            ENTITIES
            <button id="btn-spawn" class="primary">Spawn</button>
        </div>
        <div id="entity-list"></div>
    </div>

    <div id="log-panel"></div>
</div>
</div>

<!-- Modal for Assumptions -->
<div id="assumptions-modal" class="modal">
<div class="modal-content">
<div class="modal-header">SYSTEM ASSUMPTIONS & MECHANICS</div>
<ul class="assumption-list">
    <li><strong>Performance Optimizations:</strong> Heavy math operations (tanh, exp, atan) replaced with cheaper approximations</li>
    <li><strong>Activity Level:</strong> Uses softstep (smoothstep) approximation instead of tanh</li>
    <li><strong>Signature Computation:</strong> Uses log1p-based approximation for activity boost</li>
    <li><strong>Detection Score:</strong> Uses inverse-square falloff with cheaper log1p signature scaling</li>
    <li><strong>Angular Tracking:</strong> Uses polynomial approximation instead of atan for tracking difficulty</li>
    <li><strong>Clustering:</strong> Spatial hash grid for O(n) average complexity instead of O(n²)</li>
    <li><strong>Distance Caching:</strong> Quantized distance computations reduce redundant calculations</li>
    <li><strong>Telemetry Modes:</strong> 'Performance' shows minimal info, 'Full' shows full granular telemetry</li>
    <li><strong>Relative Range Rings:</strong> Each entity shows detection/weapon range rings relative to its position</li>
    <li><strong>Deterministic:</strong> All outputs are deterministic, no random toggling of debug state</li>
    <li><strong>Weapon System:</strong> Pre-baked weapon stats eliminate runtime division, use only multiplication</li>
    <li><strong>Guided Weapons:</strong> Respect lock quality for hit probability when guidance type is "guided"</li>
    <li><strong>Proportional Combat Stress:</strong> Weapon activity now scales with active weight vs installed weight for all ship sizes</li>
    <li><strong>Weapon Array System:</strong> Multiple weapon slots supported with independent counts and activation states</li>
    <li><strong>Activity Weighting:</strong> Each weapon type has baseActivityWeight (PD=5, Standard=20, Heavy=50) contributing to signature</li>
    <li><strong>Deterministic Weapon Rings:</strong> One ring per active weapon type with stable color hashing</li>
</ul>
<button onclick="document.getElementById('assumptions-modal').style.display='none'">Close</button>
</div>
</div>

<div id="import-modal" class="modal">
<div class="modal-content">
<div class="modal-header">IMPORT STATE FROM JSON</div>
<div style="margin-bottom: 10px;">
    <label for="import-file-input">Select JSON file:</label>
    <input type="file" id="import-file-input" accept=".json" style="width: 100%; margin-top: 5px;">
</div>
<div style="display: flex; gap: 10px;">
    <button id="btn-import-confirm" class="primary">Import</button>
    <button onclick="document.getElementById('import-modal').style.display='none'">Cancel</button>
</div>
</div>
</div>

<script>

// =========================================================================
// WEAPON DATABASE
// =========================================================================

const WEAPON_DB = {
  "weapons_test": [
    {
      id: "pulse_laser_mk1",
      name: "Pulse Laser Mk I (PL-1)",
      baseAccuracy: 0.78,
      effectiveRange_km: 25,
      trackingSpeed: 0.18,
      trackingSensitivity: 2.4,
      guidance: "unguided",
      baseActivityWeight: 18,
      weaponClass: "standard"
    },
    {
      id: "pulse_laser_mk2",
      name: "Pulse Laser Mk II (PL-2)",
      baseAccuracy: 0.85,
      effectiveRange_km: 28,
      trackingSpeed: 0.22,
      trackingSensitivity: 2.0,
      guidance: "unguided",
      baseActivityWeight: 22,
      weaponClass: "standard"
    },
    {
      id: "beam_laser_x1",
      name: "Beam Laser X1 (BL-X1)",
      baseAccuracy: 0.92,
      effectiveRange_km: 30,
      trackingSpeed: 0.12,
      trackingSensitivity: 2.2,
      guidance: "unguided",
      baseActivityWeight: 24,
      weaponClass: "standard"
    },
    {
      id: "autocannon_20mm",
      name: "20 mm Autocannon",
      baseAccuracy: 0.65,
      effectiveRange_km: 4,
      trackingSpeed: 0.30,
      trackingSensitivity: 1.6,
      guidance: "unguided",
      baseActivityWeight: 6,
      weaponClass: "pointdefense"
    },
    {
      id: "autocannon_75mm",
      name: "75 mm Autocannon",
      baseAccuracy: 0.72,
      effectiveRange_km: 26,
      trackingSpeed: 0.14,
      trackingSensitivity: 1.9,
      guidance: "unguided",
      baseActivityWeight: 20,
      weaponClass: "standard"
    },
    {
      id: "railgun_light",
      name: "Light Railgun (RG-L)",
      baseAccuracy: 0.88,
      effectiveRange_km: 28,
      trackingSpeed: 0.06,
      trackingSensitivity: 2.8,
      guidance: "unguided",
      baseActivityWeight: 45,
      weaponClass: "heavy"
    },
    {
      id: "railgun_heavy",
      name: "Heavy Railgun (RG-H)",
      baseAccuracy: 0.92,
      effectiveRange_km: 30,
      trackingSpeed: 0.04,
      trackingSensitivity: 3.4,
      guidance: "unguided",
      baseActivityWeight: 60,
      weaponClass: "heavy"
    },
    {
      id: "plasma_cannon",
      name: "Plasma Cannon (PC-1)",
      baseAccuracy: 0.80,
      effectiveRange_km: 27,
      trackingSpeed: 0.09,
      trackingSensitivity: 2.6,
      guidance: "unguided",
      baseActivityWeight: 28,
      weaponClass: "standard"
    },
    {
      id: "pulse_beam_field",
      name: "Pulse Field Generator (PFG-1)",
      baseAccuracy: 0.70,
      effectiveRange_km: 26,
      trackingSpeed: 0.20,
      trackingSensitivity: 2.1,
      guidance: "unguided",
      baseActivityWeight: 30,
      weaponClass: "area"
    },

    {
      id: "missile_light_flare",
      name: "Light Guided Missile (LGM-1)",
      baseAccuracy: 0.90,
      effectiveRange_km: 40,
      trackingSpeed: 0.09,
      trackingSensitivity: 1.6,
      guidance: "guided",
      baseActivityWeight: 18,
      weaponClass: "missile"
    },
    {
      id: "missile_striker",
      name: "Guided Strike Missile (GSM-2)",
      baseAccuracy: 0.95,
      effectiveRange_km: 45,
      trackingSpeed: 0.08,
      trackingSensitivity: 1.5,
      guidance: "guided",
      baseActivityWeight: 26,
      weaponClass: "missile"
    },
    {
      id: "missile_heavy_torpedo",
      name: "Heavy Torpedo (HT-1)",
      baseAccuracy: 0.98,
      effectiveRange_km: 45,
      trackingSpeed: 0.045,
      trackingSensitivity: 2.0,
      guidance: "guided",
      baseActivityWeight: 70,
      weaponClass: "heavy_missile"
    }
  ]
};

// =========================================================================
// WEAPON BAKING SYSTEM
// =========================================================================

const BAKED_WEAPONS = {};

function bakeWeaponStats(config) {
    // Unit conversion: km to meters for range calculations
    const rangeKm = config.effectiveRange_km;
    const rangeMeters = rangeKm * 1000;  // EXPLICIT UNIT CONVERSION: km → m
    
    const invRangeSq = 1.0 / (rangeMeters ** 2);
    const invTracking = 1.0 / Math.max(0.0001, config.trackingSpeed);
    const trackingSensitivity = 0.5 * (config.trackingSensitivity || 2.0);
    
    // ADD THIS: Ensure baseActivityWeight exists with default
    const activityWeight = config.baseActivityWeight !== undefined ? 
                          config.baseActivityWeight : 10;
    
    return {
        id: config.id,
        name: config.name,
        baseAccuracy: config.baseAccuracy,
        invRangeSq: invRangeSq,
        invTracking: invTracking,
        trackingSensitivity: trackingSensitivity,
        maxRangeM: rangeMeters,
        guidance: config.guidance || "unguided",
        baseActivityWeight: activityWeight,     // ADD THIS
        weaponClass: config.weaponClass || "standard", // ADD THIS
        originalConfig: config
    };
}

function computeHitProbOptimized(bakedWeapon, distSq, targetAngVel, lockQuality) {
    const distFactor = 1.0 / (1.0 + (distSq * bakedWeapon.invRangeSq));
    
    let trackingFactor = 1.0;
    
    if (bakedWeapon.guidance === "guided" && lockQuality !== undefined && lockQuality > 0.5) {
        trackingFactor = 0.95 + (lockQuality * 0.05);
    } else {
        const angRatio = targetAngVel * bakedWeapon.invTracking;
        let penalty = Math.max(0, angRatio - 1.0) * bakedWeapon.trackingSensitivity;
        if (penalty > 1.0) penalty = 1.0;
        trackingFactor = 1.0 - (penalty * penalty);
    }
    
    return bakedWeapon.baseAccuracy * distFactor * trackingFactor;
}

function initializeWeaponDatabase() {
    WEAPON_DB.weapons_test.forEach(w => {
        BAKED_WEAPONS[w.id] = bakeWeaponStats(w);
    });
    log(`Baked ${Object.keys(BAKED_WEAPONS).length} weapons`, 'INFO', 'SYS');
}

// =========================================================================
// CANONICAL WEAPON ACTIVITY FUNCTION (PROPORTIONAL COMBAT STRESS MODEL)
// =========================================================================
function calculateWeaponActivity(entity) {
    PERF_COUNTERS.weaponActivityComputations++;
    
    let installedCapacity = 0;
    let currentFiring = 0;

    if (!entity.weapons || entity.weapons.length === 0) return 0;

    entity.weapons.forEach(slot => {
        const w = BAKED_WEAPONS[slot.weaponId];
        const weight = (w && w.baseActivityWeight) ? w.baseActivityWeight : 10;
        const qty = Math.max(0, Number(slot.count) || 0);

        installedCapacity += weight * qty;
        if (slot.active && qty > 0) {
            currentFiring += weight * qty;
        }
    });

    const normalized = installedCapacity > 0 ? (currentFiring / installedCapacity) : 0;
    return Math.max(0, Math.min(1, normalized));
}

// =========================================================================
// PERFORMANCE COUNTERS
// =========================================================================

const PERF_COUNTERS = {
    activityComputations: 0,
    weaponActivityComputations: 0,
    signatureComputations: 0,
    detectionScoreComputations: 0,
    lockStateComputations: 0,
    clusterOperations: 0,
    distanceComputations: 0,
    angularVelocityComputations: 0,
    
    tanhCalls: 0,
    expCalls: 0,
    atanCalls: 0,
    sqrtCalls: 0,

    reset: function() {
        this.activityComputations = 0;
        this.weaponActivityComputations = 0;
        this.signatureComputations = 0;
        this.detectionScoreComputations = 0;
        this.lockStateComputations = 0;
        this.clusterOperations = 0;
        this.distanceComputations = 0;
        this.angularVelocityComputations = 0;
        this.tanhCalls = 0;
        this.expCalls = 0;
        this.atanCalls = 0;
        this.sqrtCalls = 0;
    },

    getReport: function() {
        return {
            total_function_calls: this.activityComputations + this.weaponActivityComputations + this.signatureComputations + 
                                 this.detectionScoreComputations + this.lockStateComputations + 
                                 this.clusterOperations + this.distanceComputations + 
                                 this.angularVelocityComputations,
            expensive_ops: this.tanhCalls + this.expCalls + this.atanCalls,
            breakdown: {
                activity: this.activityComputations,
                weaponActivity: this.weaponActivityComputations,
                signature: this.signatureComputations,
                detection: this.detectionScoreComputations,
                lockState: this.lockStateComputations,
                clustering: this.clusterOperations,
                distance: this.distanceComputations,
                angularVel: this.angularVelocityComputations
            },
            expensive_breakdown: {
                tanh: this.tanhCalls,
                exp: this.expCalls,
                atan: this.atanCalls,
                sqrt: this.sqrtCalls
            }
        };
    }
};

// =========================================================================
// FAST MATH APPROXIMATIONS
// =========================================================================

const FastMath = {
    softstep: function(x) {
        if (x <= 0) return 0;
        if (x >= 1) return 1;
        return x * x * (3 - 2 * x);
    },
    
    log1pNormalized: function(x, k) {
        const xk = x * k;
        return xk / (1 + xk);
    },
    
    inverseSquareFalloff: function(distanceKm, effectiveRange) {
        const ratio = distanceKm / effectiveRange;
        return 1 / (1 + ratio * ratio);
    },
    
    fastAtanAccurate: function(x) {
        if (x < -1) {
            return -Math.PI/2 - this.fastAtanAccurate(1/x);
        }
        if (x > 1) {
            return Math.PI/2 - this.fastAtanAccurate(1/x);
        }
        const x2 = x * x;
        return x * (0.99997726 + x2 * (-0.33262347 + x2 * (0.19354346 + x2 * (-0.11643287 + x2 * 0.05265332))));
    },
    
    fastSigmoid: function(x) {
        if (x < -4) return 0;
        if (x > 4) return 1;
        const normalized = (x + 4) / 8;
        return this.softstep(normalized);
    }
};

// =========================================================================
// SPATIAL HASH GRID
// =========================================================================

class SpatialHashGrid {
    constructor(cellSize) {
        this.cellSize = cellSize || 5000;
        this.grid = new Map();
    }
    
    clear() {
        this.grid.clear();
    }
    
    _hashKey(x, y) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        return `${cx},${cy}`;
    }
    
    insert(entity, x, y) {
        const key = this._hashKey(x, y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(entity);
    }
    
    queryRadius(x, y, radius) {
        const results = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                const key = `${cx + dx},${cy + dy}`;
                const cell = this.grid.get(key);
                if (cell) {
                    results.push(...cell);
                }
            }
        }
        return results;
    }
}

// =========================================================================
// DISTANCE CACHE
// =========================================================================

const DistanceCache = {
    _cache: new Map(),
    _quantizeStep: 10,
    
    _quantizePos(x, y) {
        const qx = Math.floor(x / this._quantizeStep) * this._quantizeStep;
        const qy = Math.floor(y / this._quantizeStep) * this._quantizeStep;
        return `${qx},${qy}`;
    },
    
    get(x1, y1, x2, y2) {
        const key = `${this._quantizePos(x1, y1)}_${this._quantizePos(x2, y2)}`;
        return this._cache.get(key);
    },
    
    set(x1, y1, x2, y2, distance) {
        const key = `${this._quantizePos(x1, y1)}_${this._quantizePos(x2, y2)}`;
        this._cache.set(key, distance);
        
        if (this._cache.size > 1000) {
            const firstKey = this._cache.keys().next().value;
            this._cache.delete(firstKey);
        }
    },
    
    clear() {
        this._cache.clear();
    }
};

// =========================================================================
// IMPROVED SENSOR MATH
// =========================================================================

const ImprovedSensorMath = {
    clamp: function(val, min, max) {
        return Math.max(min, Math.min(max, val));
    }
};

ImprovedSensorMath.SHIP_PROFILES = {
    "Interceptor": {
        baseSignature: 15,
        activityGain: 1.8,
        size: "frigate",
        description: "Fast, low signature craft"
    },
    "Corvette": {
        baseSignature: 18,
        activityGain: 1.6,
        size: "frigate",
        description: "Small patrol vessel"
    },
    "Light Frigate": {
        baseSignature: 25,
        activityGain: 1.7,
        size: "frigate",
        description: "Basic combat vessel"
    },
    "Heavy Frigate": {
        baseSignature: 35,
        activityGain: 2.0,
        size: "frigate",
        description: "Reinforced multi-role frigate"
    },
    "Destroyer": {
        baseSignature: 45,
        activityGain: 2.1,
        size: "cruiser",
        description: "Line combat vessel"
    },
    "Light Cruiser": {
        baseSignature: 55,
        activityGain: 2.2,
        size: "cruiser",
        description: "Multi-role capital ship"
    },
    "Battlecruiser": {
        baseSignature: 65,
        activityGain: 2.3,
        size: "cruiser",
        description: "Heavy firepower platform"
    },
    "Carrier": {
        baseSignature: 90,
        activityGain: 2.5,
        size: "capital",
        description: "Fighter operations, always visible"
    },
    "Dreadnought": {
        baseSignature: 85,
        activityGain: 2.4,
        size: "capital",
        description: "Maximum firepower, impossible to hide"
    },
    "Command Ship": {
        baseSignature: 75,
        activityGain: 2.6,
        size: "capital",
        description: "C&C vessel with high sensor emissions"
    }
};

ImprovedSensorMath.loadCustomProfiles = function() {
    try {
        const stored = localStorage.getItem('customShipProfiles');
        if (stored) {
            const custom = JSON.parse(stored);
            Object.assign(ImprovedSensorMath.SHIP_PROFILES, custom);
        }
    } catch (e) {
        console.error('Failed to load custom profiles:', e);
    }
};

ImprovedSensorMath.saveCustomProfile = function(name, profile) {
    try {
        const stored = localStorage.getItem('customShipProfiles');
        const custom = stored ? JSON.parse(stored) : {};
        custom[name] = profile;
        localStorage.setItem('customShipProfiles', JSON.stringify(custom));
        ImprovedSensorMath.SHIP_PROFILES[name] = profile;
        return true;
    } catch (e) {
        console.error('Failed to save custom profile:', e);
        return false;
    }
};

ImprovedSensorMath.getShipProfile = function(shipName){
    if(!shipName) shipName = '';
    const normalize = s => String(s).replace(/[\s\-_]/g,'').toLowerCase();
    if(!ImprovedSensorMath._profileLookup){
        ImprovedSensorMath._profileLookup = {};
        Object.keys(ImprovedSensorMath.SHIP_PROFILES).forEach(k=>{
            ImprovedSensorMath._profileLookup[ normalize(k) ] = ImprovedSensorMath.SHIP_PROFILES[k];
        });
    }
    const found = ImprovedSensorMath._profileLookup[ normalize(shipName) ];
    if(found) return found;
    if(ImprovedSensorMath.SHIP_PROFILES[shipName]) return ImprovedSensorMath.SHIP_PROFILES[shipName];
    return { baseSignature: 20, activityGain: 1.5, size: "frigate", description: "Default profile" };
};

ImprovedSensorMath.getAvailableShipTypes = function() {
    return Object.keys(ImprovedSensorMath.SHIP_PROFILES);
};

ImprovedSensorMath.computeActivityLevel = function(velocityRatio, weaponActivityFraction, radarActive) {
    // CHANGED: proportional weapon activity fraction
    PERF_COUNTERS.activityComputations++;
    
    velocityRatio = Math.max(0, Math.min(1, Number(velocityRatio) || 0));
    weaponActivityFraction = Math.max(0, Math.min(1, Number(weaponActivityFraction) || 0));
    const velWeight = CONFIG.get('MATH_VEL_WEIGHT');
    const weaponWeight = CONFIG.get('MATH_WEAPON_WEIGHT');
    const radarWeight = CONFIG.get('MATH_RADAR_WEIGHT');
    const sensitivity = CONFIG.get('MATH_SENSITIVITY');
    
    let rawActivity = (velocityRatio * velWeight) + (weaponActivityFraction * weaponWeight);
    if (radarActive) rawActivity += radarWeight;
    
    const centered = sensitivity * (rawActivity - 1.0);
    const normalized = (centered + 3) / 6;
    return FastMath.softstep(Math.max(0, Math.min(1, normalized)));
};

ImprovedSensorMath.computeSignature = function(shipType, activityLevel) {
    PERF_COUNTERS.signatureComputations++;
    
    const profile = ImprovedSensorMath.getShipProfile(shipType);
    const baseSig = Math.max(0, Number(profile.baseSignature) || 0);
    const gain = Math.max(0, Number(profile.activityGain) || 0);
    activityLevel = ImprovedSensorMath.clamp(Number(activityLevel) || 0, 0.0, 1.0);
    const k = CONFIG.get('MATH_SIG_K');
    
    const activityBoostNormalized = FastMath.log1pNormalized(activityLevel, k);
    const activityBoost = activityBoostNormalized * gain;
    return Math.max(0, baseSig * (1 + activityBoost));
};

ImprovedSensorMath.computeDetectionScore = function(signature, sensorPower, distanceM, opts = {}) {
    PERF_COUNTERS.detectionScoreComputations++;
    
    signature = Math.max(0, Number(signature) || 0);
    sensorPower = Math.max(0, Number(sensorPower) || 0);
    distanceM = Number(distanceM);
    if (!isFinite(distanceM) || distanceM <= 0) distanceM = 1;
    if (signature <= 0 || sensorPower <= 0) return 0;
    
    const distanceKm = distanceM / 1000;
    const effectiveRange = ('effectiveRange' in opts) ? Number(opts.effectiveRange) : CONFIG.get('MATH_EFFECTIVE_RANGE');
    const peakScore = ('peakScore' in opts) ? Number(opts.peakScore) : CONFIG.get('MATH_PEAK_SCORE');
    const referenceStrength = ('referenceStrength' in opts) ? Number(opts.referenceStrength) : CONFIG.get('MATH_REF_STRENGTH');
    
    const strength = (signature * sensorPower) / referenceStrength;
    const strengthFactor = FastMath.log1pNormalized(strength, 1.0);
    const distanceFactor = FastMath.inverseSquareFalloff(distanceKm, effectiveRange);
    
    return peakScore * strengthFactor * distanceFactor;
};

ImprovedSensorMath.isDetected = function(detectionScore, detectionThreshold) {
    detectionScore = Number(detectionScore) || 0;
    detectionThreshold = (typeof detectionThreshold === 'number') ? detectionThreshold : 15;
    detectionThreshold = Math.max(0, Number(detectionThreshold) || 0);
    return detectionScore >= detectionThreshold;
};

ImprovedSensorMath.computeDetectionRange = function(signature, sensorPower, threshold, opts = {}) {
    signature = Math.max(0, Number(signature) || 0);
    sensorPower = Math.max(0, Number(sensorPower) || 0);
    threshold = Math.max(0, Number(threshold) || 0);
    if (threshold <= 0) return Infinity;
    if (signature <= 0 || sensorPower <= 0) return 0;
    
    const peakScore = ('peakScore' in opts) ? Number(opts.peakScore) : CONFIG.get('MATH_PEAK_SCORE');
    const effectiveRange = ('effectiveRange' in opts) ? Number(opts.effectiveRange) : CONFIG.get('MATH_EFFECTIVE_RANGE');
    const referenceStrength = ('referenceStrength' in opts) ? Number(opts.referenceStrength) : CONFIG.get('MATH_REF_STRENGTH');
    
    const strength = (signature * sensorPower) / referenceStrength;
    const strengthFactor = FastMath.log1pNormalized(strength, 1.0);
    
    const maxScore = peakScore * strengthFactor;
    if (maxScore < threshold) return 0;
    
    const ratio = threshold / maxScore;
    if (ratio >= 1) return 0;
    
    const sqrtArg = (maxScore / threshold) - 1;
    if (sqrtArg < 0) return 0;
    
    PERF_COUNTERS.sqrtCalls++;
    const rangeKm = effectiveRange * Math.sqrt(sqrtArg);
    return Math.max(0, rangeKm * 1000);
};

ImprovedSensorMath.computeAngularVelocity = function(target_pos, target_vel, observer_pos, observer_vel) {
    PERF_COUNTERS.angularVelocityComputations++;
    
    const tx = (target_pos.x || 0) - (observer_pos.x || 0);
    const ty = (target_pos.y || 0) - (observer_pos.y || 0);
    const tz = ((target_pos.z || 0) - (observer_pos.z || 0));

    PERF_COUNTERS.sqrtCalls++;
    const dist = Math.sqrt(tx*tx + ty*ty + tz*tz);
    const minDist = 0.0001;

    if (!isFinite(dist) || dist < minDist) return [0.0, 0.0];

    const dir_x = tx / dist;
    const dir_y = ty / dist;
    const dir_z = tz / dist;

    const rvx = (target_vel.x || 0) - (observer_vel.x || 0);
    const rvy = (target_vel.y || 0) - (observer_vel.y || 0);
    const rvz = ((target_vel.z || 0) - (observer_vel.z || 0));

    const dot = rvx * dir_x + rvy * dir_y + rvz * dir_z;
    const lin_x = dot * dir_x;
    const lin_y = dot * dir_y;
    const lin_z = dot * dir_z;

    const trans_x = rvx - lin_x;
    const trans_y = rvy - lin_y;
    const trans_z = rvz - lin_z;

    PERF_COUNTERS.sqrtCalls++;
    const transversal_speed = Math.sqrt(trans_x*trans_x + trans_y*trans_y + trans_z*trans_z);
    const angular_velocity = transversal_speed / dist;

    if (!isFinite(angular_velocity) || !isFinite(transversal_speed)) return [0.0, 0.0];

    return [angular_velocity, transversal_speed];
};

ImprovedSensorMath.computeLockState = function(detectionScore, angularVelocity, trackingTime, trackingSpeed) {
    PERF_COUNTERS.lockStateComputations++;

    // Obtener config
    const minDetection = CONFIG.get('DETECT_THRESH'); // El umbral duro (ej. 25)
    const fullLockDetection = CONFIG.get('MATH_FULL_LOCK_DETECT'); // El umbral óptimo (ej. 50)
    
    // 1. Si estamos bajo el umbral duro, retorno inmediato 0.
    if (detectionScore < minDetection) {
        return { state: "NONE", quality: 0 };
    }

    // 2. FADE LOGIC: Normalizar el score entre el mínimo y el óptimo.
    // Esto asegura que si score == minDetection, el factor es 0.0 (0%).
    // Si score >= fullLockDetection, el factor es 1.0 (100%).
    let signalQuality = (detectionScore - minDetection) / (fullLockDetection - minDetection);
    signalQuality = Math.max(0, Math.min(1, signalQuality)); // Clamp 0-1

    // Aplicar tracking penalties (Angular, Tiempo, etc)
    const angularRatio = angularVelocity / Math.max(0.01, trackingSpeed);
    const trackingPenalty = Math.max(0, 1 - (angularRatio * 0.5)); // Penalización lineal simple
    
    // El tiempo ayuda a estabilizar
    const timeFactor = Math.min(1, trackingTime / CONFIG.get('MATH_OPTIMAL_TRACK_TIME'));
    
    // Calidad Final
    const lockQuality = signalQuality * trackingPenalty * (0.5 + 0.5 * timeFactor);

    // Determinar estado basado en la calidad suavizada
    let state = "ACQUIRING";
    if (lockQuality > 0.85) state = "LOCKED";
    else if (lockQuality > 0.20) state = "TRACKING";
    else if (lockQuality <= 0.0) state = "NONE"; // Esto ahora coincide con el anillo

    return { state: state, quality: lockQuality };
};

ImprovedSensorMath.computeHitProbability = function(baseAccuracy, distanceM, targetAngularVel, trackingSpeed) {
    baseAccuracy = Math.max(0, Math.min(1, baseAccuracy));
    trackingSpeed = Math.max(0.01, trackingSpeed || 0.05);
    const distanceKm = Math.max(0, distanceM) / 1000;
    const effectiveWeaponRange = CONFIG.get('MATH_WEAPON_RANGE');
    const trackingSteepness = CONFIG.get('MATH_TRACKING_STEEP');
    
    const distanceFactor = FastMath.inverseSquareFalloff(distanceKm, effectiveWeaponRange);
    const angularRatio = targetAngularVel / trackingSpeed;
    const trackingFactor = 1 - FastMath.fastSigmoid(trackingSteepness * (angularRatio - 1));
    
    return baseAccuracy * distanceFactor * trackingFactor;
};

ImprovedSensorMath.computeWeaponRange = function(baseAccuracy, hitThreshold) {
    hitThreshold = ImprovedSensorMath.clamp(hitThreshold || 0.5, 0.01, 1);
    baseAccuracy = ImprovedSensorMath.clamp(baseAccuracy, 0.01, 1);
    const ratio = hitThreshold / baseAccuracy;
    if (ratio >= 1) return 0;
    
    const effectiveRange = 15;
    const sqrtArg = (1 / ratio) - 1;
    if (sqrtArg < 0) return 0;
    
    PERF_COUNTERS.sqrtCalls++;
    const distKm = effectiveRange * Math.sqrt(sqrtArg);
    return Math.max(0, distKm * 1000);
};

ImprovedSensorMath.clusterTargets = function(targets, clusterRadius){
    PERF_COUNTERS.clusterOperations++;
    
    clusterRadius = Math.max(100, clusterRadius || 5000);
    const COMPRESSION_FACTOR = 0.85;
    
    if (targets.length === 0) return [];
    
    const grid = new SpatialHashGrid(clusterRadius);
    targets.forEach((t, idx) => {
        grid.insert(idx, t.x || 0, t.y || 0);
    });
    
    const clusters = [];
    const claimed = new Array(targets.length).fill(false);

    for(let i=0; i<targets.length; i++){
        if(claimed[i]) continue;
        
        const t = targets[i];
        const cluster = {
            members: [i],
            total_sig: (t.signature || 0),
            weighted_pos_x: (t.x || 0) * (t.signature || 1),
            weighted_pos_y: (t.y || 0) * (t.signature || 1),
            weighted_pos_z: (t.z || 0) * (t.signature || 1)
        };
        claimed[i] = true;

        const nearbyIndices = grid.queryRadius(t.x || 0, t.y || 0, clusterRadius);
        
        for(let j of nearbyIndices){
            if(i===j || claimed[j]) continue;
            const other = targets[j];
            const dx = (t.x||0) - (other.x||0);
            const dy = (t.y||0) - (other.y||0);
            const dz = (t.z||0) - (other.z||0);
            
            PERF_COUNTERS.sqrtCalls++;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if(dist <= clusterRadius){
                cluster.members.push(j);
                cluster.total_sig += (other.signature || 0);
                cluster.weighted_pos_x += (other.x||0) * (other.signature || 1);
                cluster.weighted_pos_y += (other.y||0) * (other.signature || 1);
                cluster.weighted_pos_z += (other.z||0) * (other.signature || 1);
                claimed[j] = true;
            }
        }

        const count = cluster.members.length;
        const display_sig = cluster.total_sig * (count>1 ? COMPRESSION_FACTOR : 1.0);
        let pos_x = 0, pos_y = 0, pos_z = 0;
        if(cluster.total_sig > 0){
            pos_x = cluster.weighted_pos_x / cluster.total_sig;
            pos_y = cluster.weighted_pos_y / cluster.total_sig;
            pos_z = cluster.weighted_pos_z / cluster.total_sig;
        }
        clusters.push({
            x: pos_x,
            y: pos_y,
            z: pos_z,
            signature: display_sig,
            count: count,
            members: cluster.members.map(idx => targets[idx])
        });
    }
    return clusters;
};

// =========================================================================
// STABLE ID GENERATOR
// =========================================================================
const IDGenerator = {
    _counter: 1,
    next: function() {
        return this._counter++;
    },
    reset: function() {
        this._counter = 1;
    }
};

// =========================================================================
// DOM ELEMENT CACHE
// =========================================================================
const DOM = {
    canvas: null,
    ctx: null,
    hudPlayerPos: null,
    hudPlayerState: null,
    hudContacts: null,
    hudLockOutgoing: null,
    hudLockIncoming: null,
    hudSelection: null,
    hudWeaponName: null,
    hudHitProb: null,
    threatWarning: null,
    rangeLegend: null,
    legendContent: null,
    
    entityControlPanel: null,
    entityControlId: null,
    entityShipType: null,
    entityProfileDesc: null,
    entityTeam: null,
    entityVel: null,
    entityVelNum: null,
    entityHead: null,
    entityHeadNum: null,
    entityWeaponsList: null,
    entitySensorPower: null,
    entitySensorPowerNum: null,
    entityEcm: null,
    entityEcmNum: null,
    
    infoSig: null,
    infoActivity: null,
    infoDetection: null,
    infoWeaponActivity: null,
    
    weaponInfoPanel: null,
    weaponNameDisplay: null,
    weaponAccuracyDisplay: null,
    weaponRangeDisplay: null,
    weaponTrackingDisplay: null,
    weaponGuidanceDisplay: null,
    weaponSensitivityDisplay: null,
    weaponDistFactor: null,
    weaponTrackFactor: null,
    weaponHitProbDisplay: null,
    weaponActivityWeightDisplay: null,
    
    entityList: null,
    logPanel: null,
    zoomSlider: null,
    zoomValNum: null,
    telemetryToggle: null,
    telemetryModeSelect: null,
    showRangeRings: null,
    showRangeLegend: null,
    relativeModeSelect: null,
    relativeIncludeAllies: null,
    relativeIncludeEnemies: null,
    relativeMaxTargets: null,
    
    init: function() {
        this.canvas = document.getElementById('main-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.hudPlayerPos = document.getElementById('hud-player-pos');
        this.hudPlayerState = document.getElementById('hud-player-state');
        this.hudContacts = document.getElementById('hud-contacts');
        this.hudLockOutgoing = document.getElementById('hud-lock-outgoing');
        this.hudLockIncoming = document.getElementById('hud-lock-incoming');
        this.hudSelection = document.getElementById('hud-selection');
        this.hudWeaponName = document.getElementById('hud-weapon-name');
        this.hudHitProb = document.getElementById('hud-hit-prob');
        this.threatWarning = document.getElementById('threat-warning');
        this.rangeLegend = document.getElementById('range-legend');
        this.legendContent = document.getElementById('legend-dynamic');
        
        this.entityControlPanel = document.getElementById('entity-control-panel');
        this.entityControlId = document.getElementById('entity-control-id');
        this.entityShipType = document.getElementById('entity-ship-type');
        this.entityProfileDesc = document.getElementById('entity-profile-description');
        this.entityTeam = document.getElementById('entity-team');
        this.entityVel = document.getElementById('entity-vel');
        this.entityVelNum = document.getElementById('entity-vel-num');
        this.entityHead = document.getElementById('entity-head');
        this.entityHeadNum = document.getElementById('entity-head-num');
        this.entityWeaponsList = document.getElementById('entity-weapons-list');
        this.entitySensorPower = document.getElementById('entity-sensor-power');
        this.entitySensorPowerNum = document.getElementById('entity-sensor-power-num');
        this.entityEcm = document.getElementById('entity-ecm');
        this.entityEcmNum = document.getElementById('entity-ecm-num');
        
        this.infoSig = document.getElementById('info-sig');
        this.infoActivity = document.getElementById('info-activity');
        this.infoDetection = document.getElementById('info-detection');
        this.infoWeaponActivity = document.getElementById('info-weapon-activity');
        
        this.weaponInfoPanel = document.getElementById('weapon-info-panel');
        this.weaponNameDisplay = document.getElementById('weapon-name-display');
        this.weaponAccuracyDisplay = document.getElementById('weapon-accuracy-display');
        this.weaponRangeDisplay = document.getElementById('weapon-range-display');
        this.weaponTrackingDisplay = document.getElementById('weapon-tracking-display');
        this.weaponGuidanceDisplay = document.getElementById('weapon-guidance-display');
        this.weaponSensitivityDisplay = document.getElementById('weapon-sensitivity-display');
        this.weaponDistFactor = document.getElementById('weapon-dist-factor');
        this.weaponTrackFactor = document.getElementById('weapon-track-factor');
        this.weaponHitProbDisplay = document.getElementById('weapon-hit-prob-display');
        this.weaponActivityWeightDisplay = document.getElementById('weapon-activity-weight-display');
        
        this.entityList = document.getElementById('entity-list');
        this.logPanel = document.getElementById('log-panel');
        this.zoomSlider = document.getElementById('zoom-slider');
        this.zoomValNum = document.getElementById('zoom-val-num');
        this.telemetryToggle = document.getElementById('telemetry-toggle');
        this.telemetryModeSelect = document.getElementById('telemetry-mode-select');
        this.showRangeRings = document.getElementById('show-range-rings');
        this.showRangeLegend = document.getElementById('show-range-legend');
        this.relativeModeSelect = document.getElementById('relative-mode-select');
        this.relativeIncludeAllies = document.getElementById('relative-include-allies');
        this.relativeIncludeEnemies = document.getElementById('relative-include-enemies');
        this.relativeMaxTargets = document.getElementById('relative-max-targets');
    }
};

// =========================================================================
// APP CONFIGURATION
// =========================================================================

const CONFIG = {
    SENSOR_STRENGTH: { name: 'Sensor Power', val: 70, min: 10, max: 200, step: 10, cat: 'sys', unit: 'score' },
    DETECT_THRESH: { name: 'Detect Threshold', val: 25, min: 5, max: 50, step: 5, cat: 'sys', unit: 'score' },
    TRACKING_SPEED: { name: 'Tracking Speed', val: 0.2, min: 0.01, max: 0.5, step: 0.01, cat: 'sys', unit: 'rad/s' },
    ECM_SCALE: { name: 'ECM Scale', val: 0.05, min: 0.01, max: 0.2, step: 0.01, cat: 'sys', unit: 'multiplier' },
    WEAPON_ACCURACY: { name: 'Base Accuracy', val: 0.85, min: 0.1, max: 1.0, step: 0.05, cat: 'sys', unit: 'probability' },
    WEAPON_TRACKING: { name: 'Weapon Tracking', val: 0.05, min: 0.01, max: 0.2, step: 0.01, cat: 'sys', unit: 'rad/s' },
    CLUSTER_RAD: { name: 'Cluster Radius', val: 5000, min: 1000, max: 20000, step: 500, cat: 'sys', unit: 'meters' },    
    MATH_VEL_WEIGHT: { name: 'Velocity Weight', val: 1.0, min: 0.1, max: 3.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_WEAPON_WEIGHT: { name: 'Weapon Weight', val: 0.8, min: 0.1, max: 2.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_RADAR_WEIGHT: { name: 'Radar Weight', val: 0.5, min: 0.1, max: 2.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_SENSITIVITY: { name: 'Activity Sensitivity', val: 1, min: 0.5, max: 4.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_SIG_K: { name: 'Signature Curve (k)', val: 9.0, min: 1.0, max: 20.0, step: 0.5, cat: 'math', unit: 'dimensionless' },
    MATH_EFFECTIVE_RANGE: { name: 'Effective Range', val: 40, min: 10, max: 200, step: 5, cat: 'math', unit: 'km' },
    MATH_PEAK_SCORE: { name: 'Peak Score', val: 70, min: 50, max: 500, step: 10, cat: 'math', unit: 'score' },
    MATH_REF_STRENGTH: { name: 'Reference Strength', val: 100, min: 10, max: 500, step: 10, cat: 'math', unit: 'score' },
    MATH_MIN_DETECTION: { name: 'Min Detection Lock', val: 10, min: 5, max: 50, step: 5, cat: 'math', unit: 'score' },
    MATH_FULL_LOCK_DETECT: { name: 'Full Lock Detection', val: 20, min: 30, max: 100, step: 5, cat: 'math', unit: 'score' },
    MATH_OPTIMAL_TRACK_TIME: { name: 'Optimal Track Time', val: 2.0, min: 0.5, max: 10.0, step: 0.5, cat: 'math', unit: 'seconds' },
    MATH_MAX_ANG_PENALTY: { name: 'Max Angular Penalty', val: 0.3, min: 0.1, max: 1.0, step: 0.05, cat: 'math', unit: 'fraction' },
    MATH_WEAPON_RANGE: { name: 'Weapon Range', val: 20, min: 5, max: 100, step: 5, cat: 'math', unit: 'km' },
    MATH_TRACKING_STEEP: { name: 'Tracking Steepness', val: 2.0, min: 0.5, max: 5.0, step: 0.1, cat: 'math', unit: 'dimensionless' },
    
    get: function(key) {
        const cfg = this[key];
        if (!cfg) return 0;
        return ImprovedSensorMath.clamp(cfg.val, cfg.min, cfg.max);
    }
};

// Team constants and colors (resolved from CSS vars with fallbacks)
const TEAMS = { ALPHA: 'alpha', BETA: 'beta', NEUTRAL: 'neutral' };
function cssVar(name, fallback) {
    const v = getComputedStyle(document.documentElement).getPropertyValue(name);
    return (v && v.trim().length) ? v.trim() : fallback;
}
const TEAM_COLORS = {
    [TEAMS.ALPHA]: {
        fill: 'rgba(0, 217, 255, 0.35)',
        stroke: cssVar('--tag-allie', '#00d9ff'),
        detectionActive: 'rgba(0, 217, 255, 0.35)',
        detectionPassive: 'rgba(210, 153, 34, 0.5)',
        weapon: 'rgba(255, 97, 80, 0.35)'
    },
    [TEAMS.BETA]: {
        fill: 'rgba(255, 69, 0, 0.35)',
        stroke: cssVar('--tag-enemy', '#ff4500'),
        detectionActive: 'rgba(255, 69, 0, 0.35)',
        detectionPassive: 'rgba(210, 153, 34, 0.5)',
        weapon: 'rgba(255, 97, 80, 0.35)'
    },
    [TEAMS.NEUTRAL]: {
        fill: 'rgba(160, 160, 160, 0.35)',
        stroke: '#bbbbbb',
        detectionActive: 'rgba(160, 160, 160, 0.35)',
        detectionPassive: 'rgba(210, 153, 34, 0.5)',
        weapon: 'rgba(255, 97, 80, 0.35)'
    }
};

// =========================================================================
// UNIVERSAL ENTITY CLASS
// =========================================================================

class Entity {
    constructor(id, x, y, shipType, team = TEAMS.NEUTRAL) {
        this.id = id;
        this.team = team;
        this.shipType = shipType || "Heavy Frigate";
        this.weapons = [];
        
        this.x = x;
        this.y = y;
        this.z = 0;
        
        this.speed = 0;
        this.heading = 0;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        
        this.radarActive = true;
        
        this.sensorMode = 'Active';
        this.sensorPower = 1.0;
        
        this.signature = 0;
        this.activityLevel = 0;
        this.weaponActivityLevel = 0;
        this.detected = false;
        this.detectionScore = 0;
        this.trackingQuality = 0;
        this.angularVelocity = 0;
        this.hitProbability = 0;
        
        this.ecm = 0;
        
        this._incomingTrackingTime = 0;
        this._prevIncomingStatus = 'NONE';
        
        this._weaponDistFactor = 0;
        this._weaponTrackFactor = 0;
    }

    // Backward compatibility: total active weapons count
    getWeaponsFiringCount() {
        if (!this.weapons || this.weapons.length === 0) return 0;
        return this.weapons.reduce((sum, slot) => sum + (slot.active ? (slot.count || 0) : 0), 0);
    }
    
    // Backward compatibility: any weapon slot active
    weaponsFiringBool() {
        if (!this.weapons || this.weapons.length === 0) return false;
        return this.weapons.some(slot => slot.active && (slot.count || 0) > 0);
    }
    
    getSizeClass() {
        return ImprovedSensorMath.getShipProfile(this.shipType).size;
    }
    
    updateVelocity() {
        this.vx = Math.cos(this.heading) * this.speed;
        this.vy = Math.sin(this.heading) * this.speed;
        this.vz = 0;
    }
    
    updateSignature() {
        const velocityRatio = this.speed / 200;
        this.weaponActivityLevel = calculateWeaponActivity(this);
        
        this.activityLevel = ImprovedSensorMath.computeActivityLevel(
            velocityRatio,
            this.weaponActivityLevel,
            this.radarActive
        );
        this.signature = ImprovedSensorMath.computeSignature(this.shipType, this.activityLevel);
    }
    
    update(dt) {
        this.updateVelocity();
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.updateSignature();
    }
}

// =========================================================================
// APP STATE
// =========================================================================

const STATE = {
    entities: [],
    outgoingLock: { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' },
    incomingLocks: [],
    selectedId: null,
    controlledId: null,
    hoveredId: null,
    cameraTargetId: null,
    playing: true,
    zoom: 0.15,
    panX: 0,
    panY: 0,
    defaultShipType: "Heavy Frigate",
    defaultTeam: TEAMS.ALPHA,
    defaultWeapon: "pulse_laser_mk1",
    telemetryMode: 'off',
    showRangeRings: true,
    showRangeLegend: true,
    _hudUpdateCounter: 0,
    _hudUpdateInterval: 3,
    _last_dt: 0.016,
    _nextSlotId: 1,
    relativeOptions: {
        mode: 'controlled', // 'controlled' or 'all'
        includeAllies: true,
        includeEnemies: true,
        maxTargets: 5
    },
    
    getControlled: function() {
        if (!this.controlledId) return null;
        return this.entities.find(e => e.id === this.controlledId) || null;
    },
    getPlayer: function() { // backward compat
        return this.getControlled();
    },

    getNextSlotId: function() {
        return this._nextSlotId++;
    },
    isBeingLocked: function(id) {
        return this.incomingLocks.some(l => l.sourceId !== id && l.status === 'LOCKED' && l.targetId === id);
    }
};

// =========================================================================
// KEYBOARD STATE
// =========================================================================

const keyState = {
    w: false, a: false, s: false, d: false,
    W: false, A: false, S: false, D: false,
    ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
};

// =========================================================================
// MATH HELPERS
// =========================================================================

function dist(a, b) {
    PERF_COUNTERS.distanceComputations++;
    
    const cached = DistanceCache.get(a.x, a.y, b.x, b.y);
    if (cached !== undefined) {
        return cached;
    }
    
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    PERF_COUNTERS.sqrtCalls++;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    DistanceCache.set(a.x, a.y, b.x, b.y, distance);
    
    return distance;
}

function rad(deg) { return deg * Math.PI / 180; }
function deg(rad) { return rad * 180 / Math.PI; }

// =========================================================================
// COLOR GENERATION FROM WEAPON ID (STABLE HUE HASH)
// =========================================================================
function colorFromWeaponId(weaponId) {
    let charSum = 0;
    for (let i = 0; i < weaponId.length; i++) {
        charSum += weaponId.charCodeAt(i);
    }
    const hue = charSum % 360;
    return `hsl(${hue}, 70%, 50%)`;
}

// Stable color for relative detection rings
const RELATIVE_RING_COLOR = 'rgba(88, 166, 255, 0.25)';

// Palette helper for legend and rings
const PALETTE = {
    weaponSample: () => colorFromWeaponId(STATE.defaultWeapon || 'pulse_laser_mk1'),
    detection: () => RELATIVE_RING_COLOR,
    entityRelative: () => 'rgba(63, 185, 80, 0.35)'
};

// =========================================================================
// POSSESSION SYSTEM
// =========================================================================

// Backward compatibility alias
function transferPossession(targetEntity) {
    setControlled(targetEntity);
}

// =========================================================================
// LOCK UPDATE FUNCTION
// =========================================================================

function updateLocks(){
    const controlled = STATE.getControlled();
    if (!controlled) return;
    
    const out = STATE.outgoingLock;
    const target = out.targetId ? STATE.entities.find(e => e.id === out.targetId) : null;
    
    if(target && target.detected){
        out.trackingTime += STATE._last_dt || 0.016;
        const targetVel = { x: Math.cos(target.heading)*target.speed, y: Math.sin(target.heading)*target.speed, z: 0 };
        const ctrlVel = { x: controlled.vx, y: controlled.vy, z: 0 };
        const angRes = ImprovedSensorMath.computeAngularVelocity({x: target.x, y: target.y, z: 0}, targetVel, {x: controlled.x, y: controlled.y, z: 0}, ctrlVel);
        const angVel = angRes[0];
        const lockResult = ImprovedSensorMath.computeLockState(target.detectionScore, angVel, out.trackingTime, CONFIG.get('TRACKING_SPEED'));
        out.status = lockResult.state;
        out.quality = lockResult.quality;
    } else {
        out.trackingTime = Math.max(0, out.trackingTime - (STATE._last_dt || 0.016) * 2);
        out.status = "NONE";
        out.quality = 0;
    }
    if(out.status !== out.prevStatus){
        log(`OutgoingLock: ${out.status} [${Math.round(out.quality*100)}%]`, 'LOCK', 'SYS');
        out.prevStatus = out.status;
    }

    STATE.incomingLocks = [];
    STATE.entities.forEach(src=>{
        if (src === controlled) return;
        if (src.team === controlled.team) return;
        
        const sourceSensorMultiplier = (src.sensorPower !== undefined) ? Number(src.sensorPower) : 1.0;
        const sourceSensorPower = CONFIG.get('SENSOR_STRENGTH') * sourceSensorMultiplier;
        const distance = dist(src, controlled);
        const detectionScoreOnControlled = ImprovedSensorMath.computeDetectionScore(controlled.signature, sourceSensorPower, distance);

        if(detectionScoreOnControlled >= CONFIG.get('DETECT_THRESH')){
            const srcVel = { x: Math.cos(src.heading)*src.speed, y: Math.sin(src.heading)*src.speed, z: 0 };
            const ctrlVel = { x: controlled.vx, y: controlled.vy, z: 0 };
            const angRes = ImprovedSensorMath.computeAngularVelocity({x: controlled.x, y: controlled.y, z: 0}, ctrlVel, {x: src.x, y: src.y, z: 0}, srcVel);
            const angVelSrc = angRes[0];

            src._incomingTrackingTime = Math.max(0, (src._incomingTrackingTime || 0) + (STATE._last_dt || 0.016));
            const lockOnControlled = ImprovedSensorMath.computeLockState(detectionScoreOnControlled, angVelSrc, src._incomingTrackingTime, CONFIG.get('TRACKING_SPEED'));

            STATE.incomingLocks.push({
                sourceId: src.id,
                targetId: controlled.id,
                status: lockOnControlled.state,
                quality: lockOnControlled.quality,
                detectionScore: detectionScoreOnControlled
            });

            if(src._prevIncomingStatus !== lockOnControlled.state){
                log(`IncomingLockFrom: ${src.id} => ${lockOnControlled.state} [${Math.round(lockOnControlled.quality*100)}%]`, 'LOCK', 'SYS');
                src._prevIncomingStatus = lockOnControlled.state;
            }
        } else {
            src._incomingTrackingTime = Math.max(0, (src._incomingTrackingTime || 0) - (STATE._last_dt || 0.016)*2);
            if(src._incomingTrackingTime <= 0){
                src._incomingTrackingTime = 0;
                if(src._prevIncomingStatus && src._prevIncomingStatus !== 'NONE'){
                    log(`IncomingLockFrom: ${src.id} LOST`, 'LOCK', 'SYS');
                }
                src._prevIncomingStatus = 'NONE';
            }
        }
    });
}

// =========================================================================
// MOVEMENT CONTROLS
// =========================================================================

function applyMovementControls(entity, dt) {
    const moveSpeed = 50;
    const turnSpeed = 1.5;
    
    let moveX = 0;
    let moveY = 0;
    let turn = 0;
    
    if (keyState.w || keyState.W || keyState.ArrowUp) moveY -= 1;
    if (keyState.s || keyState.S || keyState.ArrowDown) moveY += 1;
    if (keyState.a || keyState.A || keyState.ArrowLeft) turn -= 1;
    if (keyState.d || keyState.D || keyState.ArrowRight) turn += 1;
    
    if (turn !== 0) {
        entity.heading += turn * turnSpeed * dt;
        while (entity.heading < 0) entity.heading += Math.PI * 2;
        while (entity.heading >= Math.PI * 2) entity.heading -= Math.PI * 2;
    }
    
    if (moveY !== 0) {
        entity.speed = Math.max(0, Math.min(200, entity.speed + moveY * moveSpeed * dt));
    }
}

// =========================================================================
// SIMULATION LOOP
// =========================================================================

let lastTime = 0;

function loop(time) {
    requestAnimationFrame(loop);

    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;

    if (!STATE.playing) return;

    STATE._last_dt = dt;

    const controlled = STATE.getControlled();
    
    if (controlled) {
        applyMovementControls(controlled, dt);
        controlled.update(dt);
    }

    STATE.entities.forEach(entity => {
        if (controlled && entity.id === controlled.id) return;
        
        const vx = Math.cos(entity.heading) * entity.speed;
        const vy = Math.sin(entity.heading) * entity.speed;
        
        entity.x += vx * dt;
        entity.y += vy * dt;

        const velocityRatio = entity.speed / 200;
        entity.weaponActivityLevel = calculateWeaponActivity(entity);
        entity.activityLevel = ImprovedSensorMath.computeActivityLevel(
            velocityRatio,
            entity.weaponActivityLevel,
            entity.radarActive
        );

        entity.signature = ImprovedSensorMath.computeSignature(entity.shipType, entity.activityLevel);

        if (controlled) {
            const distance = dist(entity, controlled);
            const effectiveSensorPower = CONFIG.get('SENSOR_STRENGTH') * controlled.sensorPower;
            entity.detectionScore = ImprovedSensorMath.computeDetectionScore(
                entity.signature,
                effectiveSensorPower,
                distance
            );
            entity.detected = ImprovedSensorMath.isDetected(entity.detectionScore, CONFIG.get('DETECT_THRESH'));

            if (entity.detected) {
                const targetVel = { x: vx, y: vy, z: 0 };
                const observerVel = { x: controlled.vx, y: controlled.vy, z: 0 };
                const observerPos = { x: controlled.x, y: controlled.y, z: 0 };
                const tgtPos = { x: entity.x, y: entity.y, z: 0 };

                const angRes = ImprovedSensorMath.computeAngularVelocity(tgtPos, targetVel, observerPos, observerVel);
                entity.angularVelocity = angRes[0];
                
                const angVelWithECM = entity.angularVelocity * (1 + entity.ecm * CONFIG.get('ECM_SCALE'));
                
                const weapon = getPrimaryWeapon(controlled);
                if (weapon && controlled.weaponsFiringBool()) {
                    const dx = entity.x - controlled.x;
                    const dy = entity.y - controlled.y;
                    const distSq = dx*dx + dy*dy;
                    
                    const lockQuality = (entity.id === STATE.outgoingLock.targetId) ? STATE.outgoingLock.quality : 0;
                    
                    entity.hitProbability = computeHitProbOptimized(weapon, distSq, angVelWithECM, lockQuality);
                    
                    entity._weaponDistFactor = 1.0 / (1.0 + (distSq * weapon.invRangeSq));
                    const angRatio = angVelWithECM * weapon.invTracking;
                    let penalty = Math.max(0, angRatio - 1.0) * weapon.trackingSensitivity;
                    if (penalty > 1.0) penalty = 1.0;
                    entity._weaponTrackFactor = 1.0 - (penalty * penalty);
                } else {
                    entity.hitProbability = 0;
                    entity._weaponDistFactor = 0;
                    entity._weaponTrackFactor = 0;
                }
            } else {
                entity.angularVelocity = 0;
                entity.hitProbability = 0;
                entity._weaponDistFactor = 0;
                entity._weaponTrackFactor = 0;
            }
        }
    });

    updateLocks();
    render();
    
    const hudInterval = STATE.telemetryMode === 'full' ? 1 : 3;
    STATE._hudUpdateCounter++;
    if (STATE._hudUpdateCounter >= hudInterval) {
        STATE._hudUpdateCounter = 0;
        updateHUD();
    }
    
    updateEntityControlInfo();
    updateWeaponInfo();
}

// =========================================================================
// RENDERING
// =========================================================================

// HELPER: GET PRIMARY WEAPON
function getPrimaryWeapon(entity) {
    if (!entity || !entity.weapons || entity.weapons.length === 0) return null;
    const activeSlot = entity.weapons.find(slot => slot.active && (slot.count || 0) > 0);
    if (!activeSlot) return null;
    return BAKED_WEAPONS[activeSlot.weaponId];
}

let canvasW, canvasH;

function resizeCanvas() {
    const parent = DOM.canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    DOM.canvas.width = parent.clientWidth * dpr;
    DOM.canvas.height = parent.clientHeight * dpr;
    DOM.canvas.style.width = parent.clientWidth + 'px';
    DOM.canvas.style.height = parent.clientHeight + 'px';
    canvasW = parent.clientWidth;
    canvasH = parent.clientHeight;
    DOM.ctx.scale(dpr, dpr);
    updateZoomBounds();
}

// Dynamic zoom bounds (fit grid/world)
const GRID_WORLD_SIZE = 120000; // total width/height span to fit (in meters)
let lastMinZoom = 0.05;
function updateZoomBounds() {
    if (!DOM.zoomSlider || !DOM.zoomValNum || !canvasW || !canvasH) return;
    const padding = 10000;
    const minZoomCandidate = Math.min(
        DOM.zoomSlider.min ? parseFloat(DOM.zoomSlider.min) : 0.05,
        canvasW / (GRID_WORLD_SIZE + padding),
        canvasH / (GRID_WORLD_SIZE + padding)
    );
    const minZoom = Math.max(0.01, minZoomCandidate);
    lastMinZoom = minZoom;
    const maxZoom = parseFloat(DOM.zoomSlider.max) || 5;
    DOM.zoomSlider.min = minZoom;
    DOM.zoomValNum.min = minZoom;
    STATE.zoom = Math.min(Math.max(STATE.zoom, minZoom), maxZoom);
    DOM.zoomSlider.value = STATE.zoom;
    DOM.zoomValNum.value = STATE.zoom.toFixed(2);
}

function render() {
    window.DEBUG_LABEL_STACK = [];

    const ctx = DOM.ctx;
    const cameraTarget = STATE.cameraTargetId ? STATE.entities.find(e => e.id === STATE.cameraTargetId) : STATE.getControlled();
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dpr = window.devicePixelRatio || 1;
    ctx.scale(dpr, dpr);
    
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvasW, canvasH);

    const cx = canvasW / 2;
    const cy = canvasH / 2;

    ctx.save();
    
    const playerOffsetX = cameraTarget ? -cameraTarget.x : 0;
    const playerOffsetY = cameraTarget ? -cameraTarget.y : 0;
    
    ctx.translate(cx + STATE.panX, cy + STATE.panY);
    ctx.scale(STATE.zoom, STATE.zoom);
    ctx.translate(playerOffsetX, playerOffsetY);

    const lw = 1 / STATE.zoom;
    ctx.lineWidth = lw;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';

    const viewLeft = (-(cx + STATE.panX) / STATE.zoom) - playerOffsetX;
    const viewTop = (-(cy + STATE.panY) / STATE.zoom) - playerOffsetY;
    const viewRight = ((canvasW - (cx + STATE.panX)) / STATE.zoom) - playerOffsetX;
    const viewBottom = ((canvasH - (cy + STATE.panY)) / STATE.zoom) - playerOffsetY;

    // World → Screen helpers (uses current view and player offset)
    function worldToScreen(x, y) {
        return {
            x: (x + playerOffsetX) * STATE.zoom + cx + STATE.panX,
            y: (y + playerOffsetY) * STATE.zoom + cy + STATE.panY
        };
    }
    function worldToScreenRadius(meters) {
        return meters * STATE.zoom;
    }

    const gridSize = 1000;
    const startX = Math.floor(viewLeft / gridSize) * gridSize;
    const startY = Math.floor(viewTop / gridSize) * gridSize;

    ctx.beginPath();
    for (let x = startX; x < viewRight; x += gridSize) {
        ctx.moveTo(x, viewTop); ctx.lineTo(x, viewBottom);
    }
    for (let y = startY; y < viewBottom; y += gridSize) {
        ctx.moveTo(viewLeft, y); ctx.lineTo(viewRight, y);
    }
    ctx.stroke();

    if (STATE.showRangeRings) {
        renderWeaponRings(ctx, viewLeft, viewTop, viewRight, viewBottom, worldToScreen, worldToScreenRadius);
    }

    const teamClusters = {};
    STATE.entities.forEach(e => {
        if (!teamClusters[e.team]) teamClusters[e.team] = [];
        teamClusters[e.team].push(e);
    });

    const clusterRadius = 2000;
    const allClusters = [];
    
    Object.keys(teamClusters).forEach(team => {
        const entities = teamClusters[team];
        if (entities.length < 2) return;
        
        const claimed = new Set();
        
        entities.forEach((e, i) => {
            if (claimed.has(i)) return;
            
            const cluster = {
                team: team,
                centerX: e.x,
                centerY: e.y,
                count: 1,
                members: [i]
            };
            claimed.add(i);
            
            entities.forEach((other, j) => {
                if (i === j || claimed.has(j)) return;
                const dx = e.x - other.x;
                const dy = e.y - other.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                
                if (d <= clusterRadius) {
                    cluster.count++;
                    cluster.members.push(j);
                    claimed.add(j);
                    cluster.centerX = (cluster.centerX * (cluster.count - 1) + other.x) / cluster.count;
                    cluster.centerY = (cluster.centerY * (cluster.count - 1) + other.y) / cluster.count;
                }
            });
            
            if (cluster.count > 1) {
                allClusters.push(cluster);
            }
        });
    });

    STATE.entities.forEach(e => {
        const isSelected = e.id === STATE.selectedId;
        const teamColor = TEAM_COLORS[e.team] || TEAM_COLORS[TEAMS.NEUTRAL];
        
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(e.heading);
        
        const fillAlpha = e.detected ? 0.6 : 0.3;
        const fill = teamColor.fill.replace(/0\.35\)/, `${fillAlpha})`);
        ctx.fillStyle = fill;
        ctx.strokeStyle = teamColor.stroke;
        
        ctx.lineWidth = isSelected ? 3 / STATE.zoom : 2 / STATE.zoom;
        
        const sizeMap = { frigate: 24, cruiser: 40, capital: 70 };
        const size = sizeMap[e.getSizeClass()] || 24;
        
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.6, size * 0.5);
        ctx.lineTo(-size * 0.4, 0);
        ctx.lineTo(-size * 0.6, -size * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
        
        if (STATE.telemetryMode === 'full' && e.detected) {
            const label = buildDebugLabel(e);
            queueDebugLabel(e.x, e.y - (size + 15), label);
        }
    });

    ctx.font = `${Math.floor(16 / STATE.zoom)}px monospace`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = 3 / STATE.zoom;
    
    allClusters.forEach(cluster => {
        const text = `[${cluster.count}]`;
        const metrics = ctx.measureText(text);
        const textWidth = metrics.width;
        const textHeight = 16 / STATE.zoom;
        
        ctx.strokeText(text, cluster.centerX - textWidth / 2, cluster.centerY - textHeight - 10 / STATE.zoom);
        ctx.fillText(text, cluster.centerX - textWidth / 2, cluster.centerY - textHeight - 10 / STATE.zoom);
    });

    if (STATE.outgoingLock.status !== 'NONE' && STATE.outgoingLock.targetId) {
        const target = STATE.entities.find(e => e.id === STATE.outgoingLock.targetId);
        const ctrl = STATE.getControlled();
        if (target && ctrl) {
            ctx.strokeStyle = STATE.outgoingLock.status === 'LOCKED' ? '#d29922' : 'rgba(210, 153, 34, 0.5)';
            ctx.lineWidth = 2 / STATE.zoom;
            ctx.setLineDash([10 / STATE.zoom, 10 / STATE.zoom]);
            ctx.beginPath();
            ctx.moveTo(ctrl.x, ctrl.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    ctx.restore();
    
    renderDebugLabels(ctx, cx, cy);
}

function renderWeaponRings(ctx, viewLeft, viewTop, viewRight, viewBottom, worldToScreen, worldToScreenRadius) {
    const player = STATE.getControlled();
    if (!player) return;

    const dpr = window.devicePixelRatio || 1;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    const withinView = (entity, radius) => {
        const left = entity.x - radius;
        const right = entity.x + radius;
        const top = entity.y - radius;
        const bottom = entity.y + radius;
        return !(right < viewLeft || left > viewRight || bottom < viewTop || top > viewBottom);
    };

    // Dynamic legend only for selected entity (keeps static legend intact)
    if (DOM.legendContent && STATE.showRangeLegend) {
        DOM.legendContent.innerHTML = '';
        const selectedEntity = STATE.entities.find(e => e.id === STATE.selectedId);
        if (selectedEntity && selectedEntity.weapons) {
            const activeWeaponTypes = new Map();
            selectedEntity.weapons.forEach(slot => {
                if (slot.active && slot.count > 0) {
                    const weapon = BAKED_WEAPONS[slot.weaponId];
                    if (!weapon) return;
                    if (!activeWeaponTypes.has(slot.weaponId)) {
                        activeWeaponTypes.set(slot.weaponId, { weapon, totalCount: 0 });
                    }
                    activeWeaponTypes.get(slot.weaponId).totalCount += slot.count;
                }
            });
            activeWeaponTypes.forEach((data, weaponId) => {
                const color = colorFromWeaponId(weaponId);
                const item = document.createElement('div');
                item.className = 'legend-item';
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.background = color;
                const distanceKm = dist(selectedEntity, player) / 1000;
                const deltaKm = Math.abs(distanceKm - data.weapon.maxRangeM / 1000);
                const label = document.createElement('span');
                label.textContent = `${data.weapon.name} x${data.totalCount} (delta ${deltaKm.toFixed(2)} km)`;
                item.appendChild(colorBox);
                item.appendChild(label);
                DOM.legendContent.appendChild(item);
            });
        }
    }

    // Draw rings for focused entities (selected or hovered)
    STATE.entities.forEach(source => {
        if (!source) return;
        const isFocused = (source.id === STATE.selectedId) || (source.id === STATE.hoveredId);
        if (!isFocused) return;
        const tColors = TEAM_COLORS[source.team] || TEAM_COLORS[TEAMS.NEUTRAL];

        // Weapon rings per active weapon type
        const activeWeaponTypes = new Map();
        if (source.weapons) {
            source.weapons.forEach(slot => {
                if (slot.active && slot.count > 0) {
                    const weapon = BAKED_WEAPONS[slot.weaponId];
                    if (!weapon) return;
                    if (!activeWeaponTypes.has(slot.weaponId)) {
                        activeWeaponTypes.set(slot.weaponId, { weapon, totalCount: 0 });
                    }
                    activeWeaponTypes.get(slot.weaponId).totalCount += slot.count;
                }
            });
        }

        activeWeaponTypes.forEach((data, weaponId) => {
            const weapon = data.weapon;
            const range = weapon.maxRangeM;
            if (!withinView(source, range)) return;

            const screenRadius = worldToScreenRadius(range);
            if (screenRadius < 1) return;

            const color = tColors.weapon;
            const rgbaColor = color;

            const sc = worldToScreen(source.x, source.y);

            ctx.strokeStyle = rgbaColor;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.arc(sc.x, sc.y, screenRadius, 0, Math.PI * 2);
            ctx.stroke();

            if (STATE.telemetryMode === 'full' && source.id === STATE.selectedId) {
                const labelX = sc.x + (screenRadius / Math.SQRT2);
                const labelY = sc.y - (screenRadius / Math.SQRT2);
                const distanceKm = dist(source, player) / 1000;
                const deltaKm = Math.abs(distanceKm - weapon.maxRangeM / 1000);
                const labelText = `${weapon.name} x${data.totalCount} delta ${deltaKm.toFixed(2)}km`;

                ctx.save();
                ctx.font = `11px monospace`;
                const metrics = ctx.measureText(labelText);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(labelX + 5, labelY - 8, metrics.width + 4, 14);
                ctx.fillStyle = color;
                ctx.fillText(labelText, labelX + 7, labelY + 3);
                ctx.restore();
            }
        });

        // Relative-all detection rings (source -> targets)
        if (STATE.telemetryMode === 'relative-all') {
            const sourceSensorPower = CONFIG.get('SENSOR_STRENGTH') * (source.sensorPower || 1);
            const targets = [];
            STATE.entities.forEach(t => {
                if (t === source) return;
                if (!STATE.relativeOptions.includeAllies && t.team === source.team) return;
                if (!STATE.relativeOptions.includeEnemies && t.team !== source.team) return;
                if (STATE.relativeOptions.mode === 'controlled' && STATE.controlledId && t.id !== STATE.controlledId) return;
                targets.push(t);
            });

            // nearest N targets
            targets.sort((a, b) => dist(source, a) - dist(source, b));
            const limitedTargets = targets.slice(0, STATE.relativeOptions.maxTargets || 5);

            limitedTargets.forEach(target => {
                const detectionRadius = ImprovedSensorMath.computeDetectionRange(
                    target.signature,
                    sourceSensorPower,
                    CONFIG.get('DETECT_THRESH')
                );
                if (!isFinite(detectionRadius) || detectionRadius <= 0) return;
                if (!withinView(source, detectionRadius)) return;

                const screenRadius = worldToScreenRadius(detectionRadius);
                if (screenRadius < 1) return;

                const isPassive = !target.radarActive || target.sensorMode === 'Passive';
                ctx.strokeStyle = isPassive ? tColors.detectionPassive : tColors.detectionActive;
                ctx.lineWidth = 1.5;
                ctx.setLineDash(isPassive ? [6, 6] : []);
                const sc = worldToScreen(source.x, source.y);
                ctx.beginPath();
                ctx.arc(sc.x, sc.y, screenRadius, 0, Math.PI * 2);
                ctx.stroke();
                if (isPassive) ctx.setLineDash([]);
            });
        }
    });

    ctx.restore();
}

function buildDebugLabel(entity) {
    const player = STATE.getControlled();
    if (!player) return '';
    
    const distKm = (dist(entity, player) / 1000).toFixed(1);
    const sig = Math.round(entity.signature);
    const det = Math.round(entity.detectionScore);
    const spd = Math.round(entity.speed);
    const lock = entity.id === STATE.outgoingLock.targetId ? `[${STATE.outgoingLock.status}]` : '';
    const hitProb = (entity.hitProbability * 100).toFixed(0);
    const weapAct = ((entity.weaponActivityLevel || 0) * 100).toFixed(0);
    
    return `ID:${entity.id} ${entity.shipType.substring(0,8)} | ${distKm}km | S:${sig} D:${det} V:${spd}m/s WA:${weapAct}% H:${hitProb}% ${lock}`.trim();
}

function queueDebugLabel(x, y, text) {
    if (!window.DEBUG_LABEL_STACK) window.DEBUG_LABEL_STACK = [];
    window.DEBUG_LABEL_STACK.push({ x, y, text });
}

function renderDebugLabels(ctx, cx, cy) {
    if (!window.DEBUG_LABEL_STACK || window.DEBUG_LABEL_STACK.length === 0) return;
    
    const player = STATE.getControlled();
    
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dpr = window.devicePixelRatio || 1;
    ctx.scale(dpr, dpr);
    
    ctx.font = '10px monospace';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = 3;
    
    window.DEBUG_LABEL_STACK.forEach(label => {
        const playerOffsetX = player ? -player.x : 0;
        const playerOffsetY = player ? -player.y : 0;
        
        const screenX = cx + STATE.panX + (label.x + playerOffsetX) * STATE.zoom;
        const screenY = cy + STATE.panY + (label.y + playerOffsetY) * STATE.zoom;
        
        ctx.strokeText(label.text, screenX, screenY);
        ctx.fillText(label.text, screenX, screenY);
    });
    
    ctx.restore();
}

// =========================================================================
// HUD UPDATE
// =========================================================================

function updateHUD() {
    const player = STATE.getControlled();
    
    if (player && DOM.hudPlayerPos) {
        const px = (player.x / 1000).toFixed(1);
        const py = (player.y / 1000).toFixed(1);
        DOM.hudPlayerPos.innerText = `${px}km, ${py}km`;
    }

    if (DOM.hudContacts) {
        DOM.hudContacts.innerText = STATE.entities.length - 1;
    }

    if (DOM.hudLockOutgoing) {
        const out = STATE.outgoingLock;
        const quality = Math.round(out.quality * 100);
        DOM.hudLockOutgoing.innerText = `${out.status} (${quality}%)`;
        DOM.hudLockOutgoing.style.color = out.status === 'LOCKED' ? '#d29922' : '#58a6ff';
    }

    if (DOM.hudLockIncoming) {
        const incoming = STATE.incomingLocks.filter(l => l.status !== 'NONE');
        if (incoming.length > 0) {
            const locked = incoming.filter(l => l.status === 'LOCKED').length;
            const tracking = incoming.filter(l => l.status === 'TRACKING' || l.status === 'ACQUIRING').length;
            DOM.hudLockIncoming.innerText = `${locked} LOCKED, ${tracking} TRACKING`;
            DOM.hudLockIncoming.style.color = locked > 0 ? '#f85149' : '#d29922';
        } else {
            DOM.hudLockIncoming.innerText = 'NONE';
            DOM.hudLockIncoming.style.color = '#3fb950';
        }
    }

    if (player && DOM.hudWeaponName) {
        const weapon = getPrimaryWeapon(player);
        DOM.hudWeaponName.innerText = weapon ? weapon.name : 'NONE';
    }

    if (player && DOM.hudHitProb) {
        const target = STATE.outgoingLock.targetId ? STATE.entities.find(e => e.id === STATE.outgoingLock.targetId) : null;
        if (target && target.detected && player.weaponsFiringBool()) {
            const hitProb = (target.hitProbability * 100).toFixed(1);
            DOM.hudHitProb.innerText = `${hitProb}%`;
            DOM.hudHitProb.style.color = target.hitProbability > 0.5 ? '#3fb950' : '#d29922';
        } else {
            DOM.hudHitProb.innerText = '0%';
            DOM.hudHitProb.style.color = '#8b949e';
        }
    }

    const locked = STATE.incomingLocks.some(l => l.status === 'LOCKED');
    if (DOM.threatWarning) {
        DOM.threatWarning.classList.toggle('visible', locked);
        DOM.threatWarning.setAttribute('aria-hidden', locked ? 'false' : 'true');
    }
    
    if (DOM.rangeLegend) {
        DOM.rangeLegend.classList.toggle('shift-up', locked);
    }
    
    if (DOM.hudSelection && STATE.selectedId) {
        const e = STATE.entities.find(x => x.id === STATE.selectedId);
        if (e && player) {
            const distKm = (dist(e, player)/1000).toFixed(1);
            DOM.hudSelection.innerText = `Selected: ${e.shipType} (${distKm}km)`;
        }
    } else if (DOM.hudSelection) {
        DOM.hudSelection.innerText = '';
    }
    
    refreshEntityList();
}

// =========================================================================
// LEGEND COLOR BINDING
// =========================================================================
function applyLegendColors() {
    if (!DOM.rangeLegend) return;
    const swatches = DOM.rangeLegend.querySelectorAll('#legend-static .legend-color');
    if (swatches[0]) swatches[0].style.background = PALETTE.entityRelative();
    if (swatches[1]) swatches[1].style.background = PALETTE.detection();
    if (swatches[2]) swatches[2].style.background = PALETTE.weaponSample();
}

function updateWeaponInfo() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    const player = STATE.getControlled();
    
    if (!entity || !DOM.weaponInfoPanel) return;
    
    const primaryWeapon = getPrimaryWeapon(entity);
    
    if (primaryWeapon) {
        DOM.weaponInfoPanel.style.display = 'block';
        DOM.weaponNameDisplay.textContent = primaryWeapon.name;
        DOM.weaponAccuracyDisplay.textContent = (primaryWeapon.baseAccuracy * 100).toFixed(0) + '%';
        DOM.weaponRangeDisplay.textContent = (primaryWeapon.maxRangeM / 1000).toFixed(1) + ' km';
        DOM.weaponActivityWeightDisplay.textContent = primaryWeapon.baseActivityWeight;
        DOM.weaponTrackingDisplay.textContent = primaryWeapon.originalConfig.trackingSpeed.toFixed(3) + ' rad/s';
        DOM.weaponGuidanceDisplay.textContent = primaryWeapon.guidance.toUpperCase();
        DOM.weaponSensitivityDisplay.textContent = primaryWeapon.originalConfig.trackingSensitivity.toFixed(1);
        
        if (entity.id === STATE.controlledId) {
            const target = STATE.outgoingLock.targetId ? STATE.entities.find(e => e.id === STATE.outgoingLock.targetId) : null;
            if (target && target.detected && entity.weaponsFiringBool()) {
                DOM.weaponDistFactor.textContent = (target._weaponDistFactor * 100).toFixed(1) + '%';
                DOM.weaponTrackFactor.textContent = (target._weaponTrackFactor * 100).toFixed(1) + '%';
                DOM.weaponHitProbDisplay.textContent = (target.hitProbability * 100).toFixed(1) + '%';
                DOM.weaponHitProbDisplay.style.color = target.hitProbability > 0.5 ? 'var(--success)' : 'var(--warning)';
            } else {
                DOM.weaponDistFactor.textContent = '0%';
                DOM.weaponTrackFactor.textContent = '0%';
                DOM.weaponHitProbDisplay.textContent = '0%';
                DOM.weaponHitProbDisplay.style.color = 'var(--text-dim)';
            }
        } else {
            DOM.weaponDistFactor.textContent = '-';
            DOM.weaponTrackFactor.textContent = '-';
            DOM.weaponHitProbDisplay.textContent = '-';
        }
    } else {
        DOM.weaponInfoPanel.style.display = 'none';
    }
}

// =========================================================================
// INPUT HANDLERS
// =========================================================================

function setupInputHandlers() {
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let lastClickTime = 0;
    
    DOM.canvas.addEventListener('mousedown', (e) => {
        const currentTime = Date.now();
        const isDoubleClick = currentTime - lastClickTime < 300;
        lastClickTime = currentTime;
        
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            isDragging = true;
            dragStartX = e.clientX - STATE.panX;
            dragStartY = e.clientY - STATE.panY;
            e.preventDefault();
        } else if (e.button === 0) {
            const rect = DOM.canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            const cx = canvasW / 2;
            const cy = canvasH / 2;
            const cam = STATE.cameraTargetId ? STATE.entities.find(ent => ent.id === STATE.cameraTargetId) : STATE.getControlled();
            const playerOffsetX = cam ? -cam.x : 0;
            const playerOffsetY = cam ? -cam.y : 0;
            
            const worldX = ((mx - cx - STATE.panX) / STATE.zoom) - playerOffsetX;
            const worldY = ((my - cy - STATE.panY) / STATE.zoom) - playerOffsetY;
            
            let closestEntity = null;
            let closestDist = Infinity;
            
            STATE.entities.forEach(e => {
                const dx = e.x - worldX;
                const dy = e.y - worldY;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d < closestDist && d < 500) {
                    closestDist = d;
                    closestEntity = e;
                }
            });
            
            if (closestEntity) {
                if (isDoubleClick) {
                    transferPossession(closestEntity);
                } else {
                    selectEntity(closestEntity.id);
                }
            }
        }
    });
    
    DOM.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            STATE.panX = e.clientX - dragStartX;
            STATE.panY = e.clientY - dragStartY;
        }
    });
    
    DOM.canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });
    
    DOM.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        STATE.zoom = ImprovedSensorMath.clamp(STATE.zoom * zoomFactor, 0.05, 5);
        DOM.zoomSlider.value = STATE.zoom;
        DOM.zoomValNum.value = STATE.zoom.toFixed(2);
    });
    
    createDualInputSync(DOM.zoomSlider, DOM.zoomValNum, (val) => {
        STATE.zoom = val;
    });
    
    DOM.telemetryToggle.addEventListener('change', (e) => {
        if (e.target.checked && STATE.telemetryMode === 'off') {
            STATE.telemetryMode = 'perf';
            DOM.telemetryModeSelect.value = 'perf';
        } else if (!e.target.checked) {
            STATE.telemetryMode = 'off';
            DOM.telemetryModeSelect.value = 'off';
        }
        document.getElementById('btn-telemetry-toggle').classList.toggle('mode-active', e.target.checked);
    });
    
    DOM.telemetryModeSelect.addEventListener('change', (e) => {
        STATE.telemetryMode = e.target.value;
        DOM.telemetryToggle.checked = STATE.telemetryMode !== 'off';
        document.getElementById('btn-telemetry-toggle').classList.toggle('mode-active', STATE.telemetryMode !== 'off');
        const relOpts = document.getElementById('relative-options');
        if (relOpts) relOpts.style.display = STATE.telemetryMode === 'relative-all' ? 'block' : 'none';
    });

    if (DOM.relativeModeSelect) {
        DOM.relativeModeSelect.addEventListener('change', (e) => {
            STATE.relativeOptions.mode = e.target.value;
        });
    }
    if (DOM.relativeIncludeAllies) {
        DOM.relativeIncludeAllies.addEventListener('change', (e) => {
            STATE.relativeOptions.includeAllies = e.target.checked;
        });
    }
    if (DOM.relativeIncludeEnemies) {
        DOM.relativeIncludeEnemies.addEventListener('change', (e) => {
            STATE.relativeOptions.includeEnemies = e.target.checked;
        });
    }
    if (DOM.relativeMaxTargets) {
        DOM.relativeMaxTargets.addEventListener('change', (e) => {
            const n = Math.max(1, Math.min(50, parseInt(e.target.value) || 5));
            STATE.relativeOptions.maxTargets = n;
            e.target.value = n;
        });
    }
    
    DOM.showRangeRings.addEventListener('change', (e) => {
        STATE.showRangeRings = e.target.checked;
    });
    
    DOM.showRangeLegend.addEventListener('change', (e) => {
        STATE.showRangeLegend = e.target.checked;
        if (DOM.rangeLegend) {
            DOM.rangeLegend.classList.toggle('visible', e.target.checked);
            if (e.target.checked) applyLegendColors();
        }
    });
    
    document.getElementById('btn-play').addEventListener('click', () => {
        STATE.playing = !STATE.playing;
        document.getElementById('btn-play').innerText = STATE.playing ? 'Pause' : 'Play';
    });
    
    document.getElementById('btn-step').addEventListener('click', () => {
        if (!STATE.playing) {
            loop(performance.now());
        }
    });
    
    document.getElementById('btn-reset').addEventListener('click', resetSim);
    document.getElementById('btn-spawn').addEventListener('click', spawnEntity);
    document.getElementById('btn-telemetry-toggle').addEventListener('click', () => {
        DOM.telemetryToggle.checked = !DOM.telemetryToggle.checked;
        DOM.telemetryToggle.dispatchEvent(new Event('change'));
    });
    
    document.getElementById('btn-test-preset').addEventListener('click', () => {
        document.getElementById('import-modal').style.display = 'flex';
    });
    
    document.getElementById('btn-assumptions').addEventListener('click', () => {
        document.getElementById('assumptions-modal').style.display = 'flex';
    });
    
    document.getElementById('btn-export').addEventListener('click', exportState);
    document.getElementById('btn-run-tests').addEventListener('click', runPerfTests);
    document.getElementById('btn-import-confirm').addEventListener('click', importState);
    document.getElementById('btn-save-profile').addEventListener('click', saveCustomProfile);
    const fitBtn = document.getElementById('btn-fit-grid');
    if (fitBtn) {
        fitBtn.addEventListener('click', () => {
            const maxZoom = parseFloat(DOM.zoomSlider.max) || 5;
            STATE.zoom = Math.min(Math.max(lastMinZoom, 0.01), maxZoom);
            DOM.zoomSlider.value = STATE.zoom;
            DOM.zoomValNum.value = STATE.zoom.toFixed(2);
            render();
        });
    }
    
    window.addEventListener('keydown', (e) => {
        if (e.key in keyState) {
            keyState[e.key] = true;
            e.preventDefault();
        }
    });
    
    window.addEventListener('keyup', (e) => {
        if (e.key in keyState) {
            keyState[e.key] = false;
        }
    });
    
    setupEntityControlHandlers();
}

function setupEntityControlHandlers() {
    createDualInputSync(DOM.entityVel, DOM.entityVelNum, (val) => {
        const entity = STATE.entities.find(e => e.id === STATE.selectedId);
        if (entity) {
            entity.speed = val;
        }
    });
    
    createDualInputSync(DOM.entityHead, DOM.entityHeadNum, (val) => {
        const entity = STATE.entities.find(e => e.id === STATE.selectedId);
        if (entity) {
            entity.heading = rad(val);
        }
    });
    
    const addSlotBtn = document.getElementById('btn-add-weapon-slot');
    if (addSlotBtn) {
        addSlotBtn.addEventListener('click', addWeaponSlot);
    }
    
    document.getElementById('btn-sensor-active').addEventListener('click', () => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.sensorMode = 'Active';
            updateSensorModeButtons();
        }
    });
    
    document.getElementById('btn-sensor-passive').addEventListener('click', () => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.sensorMode = 'Passive';
            updateSensorModeButtons();
        }
    });
    
    createDualInputSync(DOM.entitySensorPower, DOM.entitySensorPowerNum, (val) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.sensorPower = val;
        }
    });
    
    createDualInputSync(DOM.entityEcm, DOM.entityEcmNum, (val) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.ecm = val;
        }
    });
    
    DOM.entityShipType.addEventListener('change', (e) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.shipType = e.target.value;
            const profile = ImprovedSensorMath.getShipProfile(e.target.value);
            DOM.entityProfileDesc.textContent = profile.description;
            const tag = entity.team === TEAMS.ALPHA ? 'ALPHA' : (entity.team === TEAMS.BETA ? 'BETA' : 'ENT');
            log(`Entity ${entity.id} ship type changed to ${e.target.value}`, 'INFO', tag);
        }
    });
    
    DOM.entityTeam.addEventListener('change', (e) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.team = e.target.value;
            const tag = entity.team === TEAMS.ALPHA ? 'ALPHA' : (entity.team === TEAMS.BETA ? 'BETA' : 'ENT');
            log(`Entity ${entity.id} team changed to ${e.target.value}`, 'INFO', tag);
            refreshEntityList();
        }
    });
    
    document.getElementById('default-ship-profile').addEventListener('change', (e) => {
        STATE.defaultShipType = e.target.value;
        const profile = ImprovedSensorMath.getShipProfile(e.target.value);
        document.getElementById('profile-description').textContent = profile.description;
    });
    
    document.getElementById('default-team').addEventListener('change', (e) => {
        STATE.defaultTeam = e.target.value;
    });
    
    document.getElementById('default-weapon').addEventListener('change', (e) => {
        STATE.defaultWeapon = e.target.value;
        applyLegendColors();
    });
}

function updateSensorModeButtons() {
    const entity = STATE.entities.find(x => x.id === STATE.selectedId);
    const active = document.getElementById('btn-sensor-active');
    const passive = document.getElementById('btn-sensor-passive');
    
    if (entity && entity.sensorMode === 'Active') {
        active.classList.add('mode-active');
        passive.classList.remove('mode-active');
    } else {
        active.classList.remove('mode-active');
        passive.classList.add('mode-active');
    }
}

function createDualInputSync(sliderElem, numberElem, callback) {
    const sync = (val) => {
        val = parseFloat(val);
        sliderElem.value = val;
        numberElem.value = val;
        if (callback) callback(val);
    };
    
    sliderElem.addEventListener('input', (e) => sync(e.target.value));
    numberElem.addEventListener('input', (e) => sync(e.target.value));
}

function saveCustomProfile() {
    const name = document.getElementById('custom-profile-name').value.trim();
    const sig = parseFloat(document.getElementById('custom-profile-sig').value);
    const gain = parseFloat(document.getElementById('custom-profile-gain').value);
    const size = document.getElementById('custom-profile-size').value;
    const desc = document.getElementById('custom-profile-desc').value.trim();
    
    if (!name) {
        alert('Please enter a profile name');
        return;
    }
    
    const profile = {
        baseSignature: sig,
        activityGain: gain,
        size: size,
        description: desc || 'Custom profile'
    };
    
    if (ImprovedSensorMath.saveCustomProfile(name, profile)) {
        log(`Custom profile "${name}" saved`, 'INFO', 'SYS');
        populateShipSelects();
        document.getElementById('custom-profile-name').value = '';
        document.getElementById('custom-profile-sig').value = '20';
        document.getElementById('custom-profile-gain').value = '1.5';
        document.getElementById('custom-profile-desc').value = '';
    } else {
        alert('Failed to save profile');
    }
}

// =========================================================================
// UI INITIALIZATION
// =========================================================================

function populateConfigControls() {
    const containers = {
        'sys': document.getElementById('params-detection-container'),
        'math': document.getElementById('params-math-container')
    };
    
    const trackingContainer = document.getElementById('params-tracking-container');
    const weaponContainer = document.getElementById('params-weapon-container');
    
    Object.keys(CONFIG).forEach(key => {
        if (key === 'get') return;
        
        const cfg = CONFIG[key];
        let container;
        
        if (key.includes('TRACKING') || key.includes('LOCK') || key.includes('ECM')) {
            container = trackingContainer;
        } else if (key.includes('WEAPON') || key.includes('ACCURACY')) {
            container = weaponContainer;
        } else if (cfg.cat === 'sys' && !key.includes('CLUSTER')) {
            container = containers['sys'];
        } else {
            container = containers['math'];
        }
        
        if (!container) return;
        
        const group = document.createElement('div');
        group.className = 'control-group';
        
        const label = document.createElement('label');
        const unitText = cfg.unit ? ` (${cfg.unit})` : '';
        label.innerHTML = `<span class="tag tag-sys">SYS</span>${cfg.name}${unitText}`;
        
        const dualInputGroup = document.createElement('div');
        dualInputGroup.className = 'dual-input-group';
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = cfg.min;
        slider.max = cfg.max;
        slider.step = cfg.step;
        slider.value = cfg.val;
        
        const numInput = document.createElement('input');
        numInput.type = 'number';
        numInput.min = cfg.min;
        numInput.max = cfg.max;
        numInput.step = cfg.step;
        numInput.value = cfg.val;
        numInput.style.width = '70px';
        
        const sync = (val) => {
            val = parseFloat(val);
            cfg.val = val;
            slider.value = val;
            numInput.value = val;
        };
        
        slider.addEventListener('input', (e) => sync(e.target.value));
        numInput.addEventListener('input', (e) => sync(e.target.value));
        
        dualInputGroup.appendChild(slider);
        dualInputGroup.appendChild(numInput);
        
        group.appendChild(label);
        group.appendChild(dualInputGroup);
        container.appendChild(group);
    });
}

function populateShipSelects() {
    const shipTypes = ImprovedSensorMath.getAvailableShipTypes();
    const selects = [DOM.entityShipType, document.getElementById('default-ship-profile')];
    
    selects.forEach(select => {
        if (!select) return;
        const currentValue = select.value;
        select.innerHTML = '';
        shipTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            select.appendChild(option);
        });
        if (currentValue && shipTypes.includes(currentValue)) {
            select.value = currentValue;
        }
    });
    
    if (DOM.entityShipType && !DOM.entityShipType.value) {
        DOM.entityShipType.value = "Heavy Frigate";
        const profile = ImprovedSensorMath.getShipProfile("Heavy Frigate");
        if (DOM.entityProfileDesc) DOM.entityProfileDesc.textContent = profile.description;
    }
    
    const defaultSelect = document.getElementById('default-ship-profile');
    if (defaultSelect && !defaultSelect.value) {
        defaultSelect.value = STATE.defaultShipType;
    }
    const defaultProfile = ImprovedSensorMath.getShipProfile(STATE.defaultShipType);
    document.getElementById('profile-description').textContent = defaultProfile.description;
}

function populateWeaponSelects() {
    const select = document.getElementById('default-weapon');
    if (!select) return;
    const currentValue = select.value;
    select.innerHTML = '';
    
    WEAPON_DB.weapons_test.forEach(w => {
        const option = document.createElement('option');
        option.value = w.id;
        option.textContent = w.name;
        select.appendChild(option);
    });
    
    if (currentValue && BAKED_WEAPONS[currentValue]) {
        select.value = currentValue;
    } else {
        select.value = STATE.defaultWeapon;
    }
}

function initUI() {
    DOM.init();
    
    initializeWeaponDatabase();
    ImprovedSensorMath.loadCustomProfiles();
    
    populateConfigControls();
    populateShipSelects();
    populateWeaponSelects();
    
    setupInputHandlers();
    applyLegendColors();
    if (DOM.telemetryModeSelect) DOM.telemetryModeSelect.value = STATE.telemetryMode;
    if (DOM.telemetryToggle) DOM.telemetryToggle.checked = STATE.telemetryMode !== 'off';
    const teleBtn = document.getElementById('btn-telemetry-toggle');
    if (teleBtn && DOM.telemetryToggle) teleBtn.classList.toggle('mode-active', DOM.telemetryToggle.checked);
    const relOpts = document.getElementById('relative-options');
    if (relOpts) relOpts.style.display = STATE.telemetryMode === 'relative-all' ? 'block' : 'none';
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    resetSim();
    
    updateSensorModeButtons();
    updateEntityControlUI();
    
    log('Enhanced sensor testbed initialized with weapon system!', 'INFO', 'ALPHA');

    loop(0);
}

function updateEntityControlUI() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    if (!entity) {
        DOM.entityControlPanel.style.display = 'none';
        return;
    }
    
    DOM.entityControlPanel.style.display = 'block';
    const teamLabel = entity.team ? entity.team.toUpperCase() : 'TEAM';
    DOM.entityControlId.innerText = `ID: ${entity.id} [${teamLabel}]`;

    DOM.entityShipType.value = entity.shipType;
    DOM.entityTeam.value = entity.team;
    
    DOM.entityVel.value = Math.round(entity.speed);
    DOM.entityVelNum.value = Math.round(entity.speed);
    DOM.entityHead.value = Math.round(deg(entity.heading));
    DOM.entityHeadNum.value = Math.round(deg(entity.heading));

    DOM.entitySensorPower.value = entity.sensorPower.toFixed(1);
    DOM.entitySensorPowerNum.value = entity.sensorPower.toFixed(1);
    DOM.entityEcm.value = entity.ecm.toFixed(1);
    DOM.entityEcmNum.value = entity.ecm.toFixed(1);
    
    const profile = ImprovedSensorMath.getShipProfile(entity.shipType);
    DOM.entityProfileDesc.textContent = profile.description;
    
    updateSensorModeButtons();
    renderWeaponSlots();
}

function updateEntityControlInfo() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    if (entity && DOM.infoSig) {
        DOM.infoSig.textContent = entity.signature.toFixed(1);
        DOM.infoActivity.textContent = (entity.activityLevel * 100).toFixed(0) + '%';
        if (DOM.infoWeaponActivity) {
            DOM.infoWeaponActivity.textContent = (entity.weaponActivityLevel * 100).toFixed(0) + '%';
        }
        
        const player = STATE.getControlled();
        if (player && entity !== player) {
            try {
                const playerSensorPower = CONFIG.get('SENSOR_STRENGTH') * player.sensorPower;
                const threshold = CONFIG.get('DETECT_THRESH');

                const range_vs_target = ImprovedSensorMath.computeDetectionRange(entity.signature, playerSensorPower, threshold);
                const intrinsicRange = ImprovedSensorMath.computeDetectionRange(1, playerSensorPower, threshold);

                const score = Math.round(entity.detectionScore);
                const rTarget = (range_vs_target / 1000).toFixed(1);
                const rIntr = (intrinsicRange / 1000).toFixed(1);

                DOM.infoDetection.textContent = `${score} (R:${rTarget}km) • INTR:${rIntr}km`;
                DOM.infoDetection.style.color = entity.detectionScore < 50 ? '#d29922' : '#58a6ff';
                
            } catch (e) {
                DOM.infoDetection.textContent = entity.detectionScore.toFixed(1);
            }
        } else {
            DOM.infoDetection.textContent = 'N/A (Player)';
        }
    }
}

// =========================================================================
// WEAPON SLOTS UI
// =========================================================================
function renderWeaponSlots() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    if (!entity || !DOM.entityWeaponsList) return;
    
    DOM.entityWeaponsList.innerHTML = '';
    
    if (!entity.weapons || entity.weapons.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.style.color = 'var(--text-dim)';
        emptyMsg.style.fontSize = '10px';
        emptyMsg.style.textAlign = 'center';
        emptyMsg.style.padding = '10px';
        emptyMsg.textContent = 'No weapons installed';
        DOM.entityWeaponsList.appendChild(emptyMsg);
        return;
    }
    
    entity.weapons.forEach((slot, index) => {
        const slotDiv = document.createElement('div');
        slotDiv.className = 'weapon-slot';
        
        const header = document.createElement('div');
        header.className = 'weapon-slot-header';
        header.innerHTML = `<span style=\"color: var(--accent); font-weight: bold;\">Slot ${index + 1}</span>`;
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'weapon-slot-delete danger';
        deleteBtn.textContent = 'X';
        deleteBtn.title = 'Remove weapon slot';
        deleteBtn.setAttribute('aria-label', 'Remove weapon slot');
        deleteBtn.onclick = () => deleteWeaponSlot(entity.id, index);
        header.appendChild(deleteBtn);
        
        slotDiv.appendChild(header);
        
        const controls = document.createElement('div');
        controls.className = 'weapon-slot-controls';
        
        const weaponSelect = document.createElement('select');
        weaponSelect.id = `weapon-slot-${slot.slotId}-weapon`;
        Object.keys(BAKED_WEAPONS).forEach(weaponId => {
            const weapon = BAKED_WEAPONS[weaponId];
            const option = document.createElement('option');
            option.value = weaponId;
            option.textContent = weapon.name;
            weaponSelect.appendChild(option);
        });
        weaponSelect.value = slot.weaponId;
        weaponSelect.onchange = (e) => updateWeaponSlot(entity.id, index, { weaponId: e.target.value });
        
        const countLabel = document.createElement('label');
        countLabel.textContent = 'Qty:';
        countLabel.style.flex = '0';
        countLabel.style.marginRight = '4px';
        countLabel.style.fontSize = '10px';
        
        const countInput = document.createElement('input');
        countInput.type = 'number';
        countInput.id = `weapon-slot-${slot.slotId}-count`;
        countInput.min = 0;
        countInput.value = slot.count || 0;
        countInput.onchange = (e) => updateWeaponSlot(entity.id, index, { count: parseInt(e.target.value) });
        
        const activeLabel = document.createElement('label');
        activeLabel.style.flex = '0';
        activeLabel.style.marginRight = '4px';
        activeLabel.style.fontSize = '10px';
        activeLabel.innerHTML = '<input type=\"checkbox\" id=\"weapon-slot-' + slot.slotId + '-active\"> Active';
        const activeCheckbox = activeLabel.querySelector('input');
        activeCheckbox.checked = slot.active;
        activeCheckbox.onchange = (e) => updateWeaponSlot(entity.id, index, { active: e.target.checked });
        
        controls.appendChild(weaponSelect);
        controls.appendChild(countLabel);
        controls.appendChild(countInput);
        controls.appendChild(activeLabel);
        
        slotDiv.appendChild(controls);
        
        const weapon = BAKED_WEAPONS[slot.weaponId];
        if (weapon && slot.count > 0) {
            const info = document.createElement('div');
            info.style.fontSize = '9px';
            info.style.color = 'var(--text-dim)';
            info.style.marginTop = '4px';
            info.textContent = `Range: ${(weapon.maxRangeM / 1000).toFixed(1)}km | Weight: ${weapon.baseActivityWeight}`;
            slotDiv.appendChild(info);
        }
        
        DOM.entityWeaponsList.appendChild(slotDiv);
    });
}

function addWeaponSlot() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    if (!entity) return;
    
    if (!entity.weapons) entity.weapons = [];
    
    entity.weapons.push({
        weaponId: "pulse_laser_mk1",
        count: 1,
        active: false,
        slotId: STATE.getNextSlotId()
    });
    
    renderWeaponSlots();
    entity.updateSignature();
    updateEntityControlInfo();
    updateWeaponInfo();
}

function updateWeaponSlot(entityId, slotIndex, updates) {
    const entity = STATE.entities.find(e => e.id === entityId);
    if (!entity || !entity.weapons || slotIndex >= entity.weapons.length) return;
    
    Object.assign(entity.weapons[slotIndex], updates);
    renderWeaponSlots();
    entity.updateSignature();
    updateEntityControlInfo();
    updateWeaponInfo();
}

function deleteWeaponSlot(entityId, slotIndex) {
    const entity = STATE.entities.find(e => e.id === entityId);
    if (!entity || !entity.weapons || slotIndex >= entity.weapons.length) return;
    
    entity.weapons.splice(slotIndex, 1);
    renderWeaponSlots();
    entity.updateSignature();
    updateEntityControlInfo();
    updateWeaponInfo();
}

function spawnEntity() {
    const id = IDGenerator.next();
    const player = STATE.getControlled();
    
    let offsetX, offsetY;
    if (STATE.defaultTeam === TEAMS.BETA) {
        offsetX = 40000 + (Math.random() - 0.5) * 5000;
        offsetY = (Math.random() - 0.5) * 5000;
    } else {
        offsetX = (Math.random() - 0.5) * 10000;
        offsetY = (Math.random() - 0.5) * 10000 - 5000;
    }
    
    const entity = new Entity(
        id,
        (player ? player.x : 0) + offsetX,
        (player ? player.y : 0) + offsetY,
        STATE.defaultShipType,
        STATE.defaultTeam
    );
    entity.speed = 50 + Math.random() * 50;
    entity.weapons = [
        { weaponId: STATE.defaultWeapon, count: 1, active: false, slotId: STATE.getNextSlotId() }
    ];
    
    if (STATE.defaultTeam === TEAMS.ALPHA) {
        entity.heading = 0;
    } else {
        entity.heading = Math.PI;
    }
    
    entity.team = STATE.defaultTeam;
    STATE.entities.push(entity);
    selectEntity(id);
    log(`Spawned ${entity.shipType} (ID: ${id}, Team: ${entity.team})`, 'INFO', entity.team === TEAMS.ALPHA ? 'ALPHA' : 'BETA');
}

function resetSim() {
    STATE._nextSlotId = 1;
    STATE.entities = [];
    IDGenerator.reset();

    const alpha = new Entity(IDGenerator.next(), 0, 0, "Heavy Frigate", TEAMS.ALPHA);
    alpha.weapons = [
        { weaponId: STATE.defaultWeapon, count: 2, active: false, slotId: STATE.getNextSlotId() }
    ];
    const beta = new Entity(IDGenerator.next(), 15000, 0, "Heavy Frigate", TEAMS.BETA);
    beta.weapons = [
        { weaponId: STATE.defaultWeapon, count: 2, active: false, slotId: STATE.getNextSlotId() }
    ];
    beta.heading = Math.PI;

    STATE.entities.push(alpha, beta);
    STATE.selectedId = alpha.id;
    STATE.controlledId = alpha.id;
    STATE.cameraTargetId = alpha.id;
    updateEntityControlUI();
    
    STATE.outgoingLock = { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' };
    STATE.incomingLocks = [];
    DistanceCache.clear();
    
    log('Simulation reset', 'WARN', 'SYS');
}

function selectEntity(id) {
    STATE.selectedId = id;

    if (STATE.outgoingLock.targetId !== id) {
        STATE.outgoingLock.targetId = id;
        STATE.outgoingLock.trackingTime = 0;
        log(`Targeting ID ${id}`, 'INFO', 'SYS');
    }

    updateEntityControlUI();
    updateEntityControlInfo();

    document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('active-entity'));
    const item = document.getElementById(`ent-${id}`);
    if (item) item.classList.add('active-entity');
}

function deleteEntity(id) {
    const entity = STATE.entities.find(e => e.id === id);
    if (!entity) return;
    
    if (entity.id === STATE.controlledId) {
        log('Cannot delete controlled entity', 'WARN', 'SYS');
        return;
    }
    
    STATE.entities = STATE.entities.filter(e => e.id !== id);
    STATE.incomingLocks = STATE.incomingLocks.filter(l => l.sourceId !== id);
    if (STATE.outgoingLock.targetId === id) {
        STATE.outgoingLock = { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' };
    }
    DistanceCache.clear();
    
    if (STATE.selectedId === id) {
        const ctrl = STATE.getControlled();
        STATE.selectedId = ctrl ? ctrl.id : null;
        updateEntityControlUI();
    }
    
    if (STATE.outgoingLock.targetId === id) {
        STATE.outgoingLock.targetId = null;
        STATE.outgoingLock.trackingTime = 0;
        STATE.outgoingLock.status = 'NONE';
    }
    
    refreshEntityList();
    render();
    log(`Deleted entity ${id}`, 'INFO', 'SYS');
}

function refreshEntityList() {
    if (!DOM.entityList) return;
    
    const ctrl = STATE.getControlled();
    
    DOM.entityList.innerHTML = '';
    STATE.entities.forEach(e => {
        const div = document.createElement('div');
        div.className = `entity-item ${e.id === STATE.selectedId ? 'active-entity' : ''}`;
        div.id = `ent-${e.id}`;

        const isAlly = ctrl ? (e.team === ctrl.team) : false;
        let tagCls = isAlly ? 'tag-allie' : 'tag-enemy';
        let tagTxt = isAlly ? 'ALPHA' : 'BETA';
        if (!ctrl) { tagCls = 'tag-plr'; tagTxt = e.team || 'TEAM'; }

        const distanceKm = ctrl ? (dist(e, ctrl)/1000).toFixed(1) : '?';
        
        const infoSpan = document.createElement('span');
        infoSpan.innerHTML = `<span class="tag ${tagCls}">${tagTxt}</span> <span>${e.shipType.substring(0, 12)}</span> <span>${distanceKm}km</span>`;
        infoSpan.onclick = () => selectEntity(e.id);
        infoSpan.style.flex = '1';
        infoSpan.style.cursor = 'pointer';
        
        div.appendChild(infoSpan);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'X';
        deleteBtn.className = 'danger delete-btn';
        deleteBtn.title = 'Delete entity';
        deleteBtn.setAttribute('aria-label', 'Delete entity');
        deleteBtn.onclick = (event) => {
            event.stopPropagation();
            deleteEntity(e.id);
        };
        div.appendChild(deleteBtn);
        
        DOM.entityList.appendChild(div);
    });
}

function exportState() {
    const exportData = {
        entities: STATE.entities.map(e => ({
            id: e.id,
            x: e.x,
            y: e.y,
            speed: e.speed,
            heading: e.heading,
            shipType: e.shipType,
            team: e.team,
            weapons: e.weapons,
            ecm: e.ecm,
            sensorPower: e.sensorPower,
            sensorMode: e.sensorMode
        })),
        config: Object.keys(CONFIG).filter(k => k !== 'get').reduce((acc, k) => {
            acc[k] = CONFIG[k].val;
            return acc;
        }, {}),
        zoom: STATE.zoom,
        panX: STATE.panX,
        panY: STATE.panY,
        defaultShipType: STATE.defaultShipType,
        defaultTeam: STATE.defaultTeam,
        defaultWeapon: STATE.defaultWeapon,
        nextSlotId: STATE._nextSlotId
    };
    
    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sensor_testbed_state.json';
    a.click();
    URL.revokeObjectURL(url);
    
    log('State exported to JSON', 'INFO', 'SYS');
}

function importState() {
    const fileInput = document.getElementById('import-file-input');
    const file = fileInput.files[0];
    
    if (!file) {
        alert('Please select a file');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            
            STATE.entities = [];
            IDGenerator.reset();
            STATE._nextSlotId = 1;
            
            if (data.entities && Array.isArray(data.entities)) {
                const validationReport = [];
                data.entities.forEach(eData => {
                    const entity = new Entity(
                        IDGenerator.next(),
                        eData.x || 0,
                        eData.y || 0,
                        eData.shipType || "Heavy Frigate",
                        eData.team || TEAMS.NEUTRAL
                    );
                    entity.speed = eData.speed || 0;
                    entity.heading = eData.heading || 0;
                    entity.team = eData.team || TEAMS.NEUTRAL;
                    entity.ecm = eData.ecm || 0;
                    entity.sensorPower = eData.sensorPower || 1.0;
                    entity.sensorMode = eData.sensorMode || 'Active';
                    
                    if (eData.weapons && Array.isArray(eData.weapons)) {
                        entity.weapons = eData.weapons.map(slot => {
                            if (!BAKED_WEAPONS[slot.weaponId]) {
                                validationReport.push(`Entity ${entity.id}: Unknown weapon '${slot.weaponId}' - disabled`);
                                return {
                                    weaponId: slot.weaponId,
                                    count: slot.count || 0,
                                    active: false,
                                    slotId: slot.slotId || STATE.getNextSlotId(),
                                    _unknown: true
                                };
                            }
                            return {
                                weaponId: slot.weaponId,
                                count: slot.count || 0,
                                active: slot.active || false,
                                slotId: slot.slotId || STATE.getNextSlotId()
                            };
                        });
                    } else if (eData.weaponId) {
                        entity.weapons = [{
                            weaponId: eData.weaponId,
                            count: 1,
                            active: eData.weaponsFiring || false,
                            slotId: STATE.getNextSlotId()
                        }];
                    }
                    
                    STATE.entities.push(entity);
                });
                
                if (validationReport.length > 0) {
                    console.warn('Import validation warnings:', validationReport);
                    log(`State imported with ${validationReport.length} warnings (see console)`, 'WARN', 'SYS');
                } else {
                    log('State imported from JSON', 'INFO', 'SYS');
                }
            }
            
            if (data.config) {
                Object.keys(data.config).forEach(k => {
                    if (CONFIG[k]) {
                        CONFIG[k].val = data.config[k];
                    }
                });
            }
            
            if (data.zoom !== undefined) {
                STATE.zoom = data.zoom;
                DOM.zoomSlider.value = STATE.zoom;
                DOM.zoomValNum.value = STATE.zoom.toFixed(2);
            }
            if (data.panX !== undefined) STATE.panX = data.panX;
            if (data.panY !== undefined) STATE.panY = data.panY;
            if (data.defaultShipType) STATE.defaultShipType = data.defaultShipType;
            if (data.defaultTeam) STATE.defaultTeam = data.defaultTeam;
            if (data.defaultWeapon) STATE.defaultWeapon = data.defaultWeapon;
            if (data.nextSlotId) STATE._nextSlotId = data.nextSlotId;
            
            const playerEntity = STATE.getControlled();
            if (playerEntity) {
                STATE.selectedId = playerEntity.id;
                updateEntityControlUI();
            }
            
            document.getElementById('import-modal').style.display = 'none';
            
            
        } catch (err) {
            console.error('Import error:', err);
            alert('Failed to import state: ' + err.message);
        }
    };
    
    reader.readAsText(file);
}

function log(msg, type='INFO', tag='') {
    if (!DOM.logPanel) return;
    
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    const time = new Date().toISOString().substr(11, 8);
    const tagHtml = tag ? `<span class="log-tag">[${tag}]</span>` : '';
    entry.innerHTML = `<span class="log-time">[${time}]</span>${tagHtml}<span class="log-type-${type}">${type}</span>: ${msg}`;
    DOM.logPanel.prepend(entry);
    if (DOM.logPanel.childNodes.length > 50) DOM.logPanel.lastChild.remove();
}

// =========================================================================
// PERFORMANCE TEST HARNESS
// =========================================================================

function runPerfTests() {
    log('Starting performance test harness...', 'INFO', 'SYS');
    
    const savedEntities = STATE.entities;
    
    PERF_COUNTERS.reset();
    
    const syntheticEntities = [];
    
    for (let i = 0; i < 19; i++) {
        const entity = {
            id: i,
            x: (Math.random() - 0.5) * 100000,
            y: (Math.random() - 0.5) * 100000,
            z: 0,
            speed: Math.random() * 200,
            heading: Math.random() * Math.PI * 2,
            shipType: ["Interceptor", "Corvette", "Light Frigate", "Heavy Frigate", "Destroyer"][Math.floor(Math.random() * 5)],
            weapons: [
                { weaponId: "pulse_laser_mk1", count: Math.floor(Math.random() * 4) + 1, active: Math.random() > 0.5, slotId: 1 }
            ],
            radarActive: true,
            signature: 0,
            activityLevel: 0,
            weaponActivityLevel: 0,
            detectionScore: 0,
            team: TEAMS.ALPHA
        };
        syntheticEntities.push(entity);
    }
    
    for (let i = 19; i < 39; i++) {
        const entity = {
            id: i,
            x: (Math.random() - 0.5) * 100000,
            y: (Math.random() - 0.5) * 100000,
            z: 0,
            speed: Math.random() * 200,
            heading: Math.random() * Math.PI * 2,
            shipType: ["Interceptor", "Corvette", "Light Frigate", "Heavy Frigate", "Destroyer"][Math.floor(Math.random() * 5)],
            weapons: [
                { weaponId: "pulse_laser_mk1", count: Math.floor(Math.random() * 4) + 1, active: Math.random() > 0.5, slotId: 1 }
            ],
            radarActive: true,
            signature: 0,
            activityLevel: 0,
            weaponActivityLevel: 0,
            detectionScore: 0,
            team: TEAMS.BETA
        };
        syntheticEntities.push(entity);
    }
    
    const observer = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 };
    
    const iterations = 10;
    const startTime = performance.now();
    
    for (let iter = 0; iter < iterations; iter++) {
        syntheticEntities.forEach(e => {
            const velocityRatio = e.speed / 200;
            e.weaponActivityLevel = calculateWeaponActivity(e);
            e.activityLevel = ImprovedSensorMath.computeActivityLevel(
                velocityRatio,
                e.weaponActivityLevel,
                e.radarActive
            );
            
            e.signature = ImprovedSensorMath.computeSignature(e.shipType, e.activityLevel);
            
            const dx = e.x - observer.x;
            const dy = e.y - observer.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            e.detectionScore = ImprovedSensorMath.computeDetectionScore(
                e.signature,
                CONFIG.get('SENSOR_STRENGTH'),
                distance
            );
            
            const vel = { x: Math.cos(e.heading) * e.speed, y: Math.sin(e.heading) * e.speed, z: 0 };
            const pos = { x: e.x, y: e.y, z: e.z };
            ImprovedSensorMath.computeAngularVelocity(pos, vel, observer, { x: 0, y: 0, z: 0 });
        });
        
        ImprovedSensorMath.clusterTargets(syntheticEntities, CONFIG.get('CLUSTER_RAD'));
    }
    
    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    const report = PERF_COUNTERS.getReport();
    
    log(`PERF TEST COMPLETE: ${iterations} iterations, 39 entities (19 allies + 20 enemies)`, 'INFO', 'SYS');
    log(`Total time: ${totalTime.toFixed(2)}ms (${(totalTime/iterations).toFixed(2)}ms per iteration)`, 'INFO', 'SYS');
    log(`Total function calls: ${report.total_function_calls}`, 'INFO', 'SYS');
    log(`Expensive ops (tanh+exp+atan): ${report.expensive_ops}`, 'INFO', 'SYS');
    log(`Activity computations: ${report.breakdown.activity}`, 'INFO', 'SYS');
    log(`Weapon activity computations: ${report.breakdown.weaponActivity}`, 'INFO', 'SYS');
    log(`Signature computations: ${report.breakdown.signature}`, 'INFO', 'SYS');
    log(`Detection score computations: ${report.breakdown.detection}`, 'INFO', 'SYS');
    log(`sqrt calls: ${report.expensive_breakdown.sqrt}`, 'INFO', 'SYS');
    
    console.log('=== PERFORMANCE TEST REPORT ===');
    console.log('Total time:', totalTime.toFixed(2), 'ms');
    console.log('Per iteration:', (totalTime/iterations).toFixed(2), 'ms');
    console.log('Per entity per iteration:', (totalTime/(iterations*39)).toFixed(4), 'ms');
    console.log('Function calls:', report);
    
    STATE.entities = savedEntities;
    
    log('performance test complete and check console', 'INFORMATION', 'SYSTEM INFORMATION');
}

// Start
initUI();

</script>

</body>
</html>